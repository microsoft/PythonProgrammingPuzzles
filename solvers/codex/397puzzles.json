[
  {
    "name": "Study_1:0",
    "sat": "def sat(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 0",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string with 1000 'o's but no two adjacent 'o's.\"\"\"",
    "sol_bodies": [
      "    return ('h' + 'o') * 1000"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_2:0",
    "sat": "def sat(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string with 1000 'o's, 100 pairs of adjacent 'o's and 801 copies of 'ho'.\"\"\"",
    "sol_bodies": [
      "    return 'ho' * (800 + 1) + 'o' * (100 * 2 - 1)"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_3:0",
    "sat": "def sat(li: List[int]):\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998.\"\"\"",
    "sol_bodies": [
      "    return [((i + 1) % 999) for i in range(999)]"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_4:0",
    "sat": "def sat(li: List[int]):\n    return len(li) == 10 and li.count(li[3]) == 2",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of length 10 where the fourth element occurs exactly twice.\"\"\"",
    "sol_bodies": [
      "    return list(range(10 // 2)) * 2"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_5:0",
    "sat": "def sat(li: List[int]):\n    return all([li.count(i) == i for i in range(10)])",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9.\"\"\"",
    "sol_bodies": [
      "    return [i for i in range(10) for j in range(i)]"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_6:0",
    "sat": "def sat(i: int):\n    return i % 123 == 4 and i > 10 ** 10",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find an integer greater than 10^10 which is 4 mod 123.\"\"\"",
    "sol_bodies": [
      "    return 4 + 10 ** 10 + 123 - 10 ** 10 % 123"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_7:0",
    "sat": "def sat(s: str):\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888.\"\"\"",
    "sol_bodies": [
      "    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_8:0",
    "sat": "def sat(ls: List[str]):\n    return ls[1234] in ls[1235] and ls[1234] != ls[1235]",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of more than 1235 strings such that the 1234th string is a proper substring of the 1235th.\"\"\"",
    "sol_bodies": [
      "    return [''] * 1235 + ['a']"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_9:0",
    "sat": "def sat(li: List[int]):\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to get\n    the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\n    mappings.\n    \"\"\"",
    "sol_bodies": [
      "    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_10:0",
    "sat": "def sat(s: str):\n    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a palindrome of length greater than 11 in the decimal representation of 8^1818.\"\"\"",
    "sol_bodies": [
      "    s = str(8 ** 1818)\n    return next(s[i: i + le]\n                for le in range(12, len(s) + 1)\n                for i in range(len(s) - le + 1)\n                if s[i: i + le] == s[i: i + le][::-1]\n                )"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_11:0",
    "sat": "def sat(ls: List[str]):\n    return min(ls) == max(ls) == str(len(ls))",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\n    and is equal to the lexicographically smallest element.\n    \"\"\"",
    "sol_bodies": [
      "    return ['1']"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_12:0",
    "sat": "def sat(li: List[int]):\n    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of 1,000 integers where every two adjacent integers sum to 9, and where the first\n    integer plus 4 is 9.\"\"\"",
    "sol_bodies": [
      "    return [9 - 4, 4] * (1000 // 2)"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_13:0",
    "sat": "def sat(x: float):\n    return str(x - 3.1415).startswith(\"123.456\")",
    "ans_type": "float",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456.\"\"\"",
    "sol_bodies": [
      "    return 123.456 + 3.1415"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_14:0",
    "sat": "def sat(li: List[int]):\n    return all([sum(li[:i]) == i for i in range(20)])",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of integers such that the sum of the first i integers is i, for i=0, 1, 2, ..., 19.\"\"\"",
    "sol_bodies": [
      "    return [1] * 20"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_15:0",
    "sat": "def sat(li: List[int]):\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19.\"\"\"",
    "sol_bodies": [
      "    return [(2 ** i) for i in range(20)]"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_16:0",
    "sat": "def sat(s: str):\n    return float(s) + len(s) == 4.5",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a real number such that when you add the length of its decimal representation to it, you get 4.5.\n    Your answer should be the string form of the number in its decimal representation.\"\"\"",
    "sol_bodies": [
      "    return str(4.5 - len(str(4.5)))"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_17:0",
    "sat": "def sat(i: int):\n    return len(str(i + 1000)) > len(str(i + 1001))",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001.\"\"\"",
    "sol_bodies": [
      "    return -1001"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_18:0",
    "sat": "def sat(ls: List[str]):\n    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of strings that when you combine them in all pairwise combinations gives the six strings:\n    'berlin', 'berger', 'linber', 'linger', 'gerber', 'gerlin'\n    \"\"\"",
    "sol_bodies": [
      "    seen = set()\n    ans = []\n    for s in 'berlin berger linber linger gerber gerlin'.split():\n        t = s[:3]\n        if t not in seen:\n            ans.append(t)\n            seen.add(t)\n    return ans"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_19:0",
    "sat": "def sat(li: List[int]):\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    That is find L such that, { i + j | i, j in L } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    \"\"\"",
    "sol_bodies": [
      "    return [0, 1, 2, 3, 17]"
    ],
    "module": "study.py",
    "notes": "9/15/2021 Updated to take a list rather than a set because it was the only puzzle in the repo with Set argument.",
    "weight": 1.0
  },
  {
    "name": "Study_20:0",
    "sat": "def sat(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\n    \"\"\"",
    "sol_bodies": [
      "    return [1, 3, 4, 12, 13, 14, 42, 126, 127]"
    ],
    "module": "study.py",
    "notes": "A more interesting version of this puzzle with a length constraint is ShortIntegerPath in graphs.py",
    "weight": 1.0
  },
  {
    "name": "Study_21:0",
    "sat": "def sat(li: List[int]):\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list integers containing exactly three distinct values, such that no integer repeats\n    twice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)\n    \"\"\"",
    "sol_bodies": [
      "    return list(range(3)) * 10"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_22:0",
    "sat": "def sat(s: str):\n    return s[::2] in s and len(set(s)) == 5",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a string s containing exactly five distinct characters which also contains as a substring every other\n    character of s (e.g., if the string s were 'parrotfish' every other character would be 'profs').\n    \"\"\"",
    "sol_bodies": [
      "    return \"\"\"abacadaeaaaaaaaaaa\"\"\""
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_23:0",
    "sat": "def sat(ls: List[str]):\n    return tuple(ls) in zip('dee', 'doo', 'dah!')",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.\n    \"\"\"",
    "sol_bodies": [
      "    return list(next(zip('dee', 'doo', 'dah!')))"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_24:0",
    "sat": "def sat(li: List[int]):\n    return li.count(17) == 3 and li.count(3) >= 2",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of integers with exactly three occurrences of seventeen and at least two occurrences of three.\"\"\"",
    "sol_bodies": [
      "    return [17] * 3 + [3] * 2"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_25:0",
    "sat": "def sat(s: str):\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a permutation of the string 'Permute me true' which is a palindrome.\"\"\"",
    "sol_bodies": [
      "    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_26:0",
    "sat": "def sat(ls: List[str]):\n    return \"\".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Divide the decimal representation of 8^88 up into strings of length eight.\"\"\"",
    "sol_bodies": [
      "    return [str(8 ** 88)[i:i + 8] for i in range(0, len(str(8 ** 88)), 8)]"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_27:0",
    "sat": "def sat(li: List[int]):\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\n    v the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\n    share the same great-grandchildren. Represented this digraph by the list of children indices.\n    \"\"\"",
    "sol_bodies": [
      "    return [1, 2, 3, 3]"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Study_28:0",
    "sat": "def sat(li: List[int]):\n    return all(i in range(1000) and abs(i - j) >= 10 for i in li for j in li if i != j) and len(set(li)) == 100",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of one hundred integers between 0 and 999 which all differ by at least ten from one another.\"\"\"",
    "sol_bodies": [
      "    return list(range(0, 1000, 10))"
    ],
    "module": "study.py",
    "notes": "9/15/2021: updated to a list since sets were removed from puzzle formats",
    "weight": 1.0
  },
  {
    "name": "Study_29:0",
    "sat": "def sat(l: List[int]):\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j) and len(set(l)) > 995",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of more than 995 distinct integers between 0 and 999, inclusive, such that each pair of integers\n    have squares that differ by at least 10.\n    \"\"\"",
    "sol_bodies": [
      "    return [0, 4] + list(range(6, 1000))"
    ],
    "module": "study.py",
    "notes": "9/15/2021: updated to a list since sets were removed from puzzle formats",
    "weight": 1.0
  },
  {
    "name": "Study_30:0",
    "sat": "def sat(li: List[int]):\n    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Define f(n) to be the residue of 123 times n mod 1000. Find a list of integers such that the first twenty one\n    are between 0 and 999, inclusive, and are strictly increasing in terms of f(n).\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(range(1000), key=lambda n: 123 * n % 1000)[:21]",
      "    return list(range(1000))[::8][::-1]"
    ],
    "module": "study.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "TowersOfHanoi:0",
    "sat": "def sat(moves: List[List[int]]):\n    rods = ([8, 7, 6, 5, 4, 3, 2, 1], [], [])\n    for [i, j] in moves:\n        rods[j].append(rods[i].pop())\n        assert rods[j][-1] == min(rods[j]), \"larger disk on top of smaller disk\"\n    return rods[0] == rods[1] == []",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Eight disks of sizes 1-8 are stacked on three towers, with each tower having disks in order of largest to\n    smallest. Move [i, j] corresponds to taking the smallest disk off tower i and putting it on tower j, and it\n    is legal as long as the towers remain in sorted order. Find a sequence of moves that moves all the disks\n    from the first to last towers.\n    \"\"\"",
    "sol_bodies": [
      "    def helper(m, i, j):\n        if m == 0:\n            return []\n        k = 3 - i - j\n        return helper(m - 1, i, k) + [[i, j]] + helper(m - 1, k, j)\n\n    return helper(8, 0, 2)"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this classic version one must move all 8 disks from the first to third peg.",
    "weight": 1.0
  },
  {
    "name": "TowersOfHanoiArbitrary:0",
    "sat": "def sat(moves: List[List[int]], source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):\n    state = [s[:] for s in source]\n\n    for [i, j] in moves:\n        state[j].append(state[i].pop())\n        assert state[j] == sorted(state[j])\n\n    return state == target",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(source=[[0, 7], [4, 5, 6], [1, 2, 3, 8]], target=[[0, 1, 2, 3, 8], [4, 5], [6, 7]]):",
    "sol_docstring": "    \"\"\"\n    A state is a partition of the integers 0-8 into three increasing lists. A move is pair of integers i, j in\n    {0, 1, 2} corresponding to moving the largest number from the end of list i to list j, while preserving the\n    order of list j. Find a sequence of moves that transform the given source to target states.\n    \"\"\"",
    "sol_bodies": [
      "    state = {d: i for i, tower in enumerate(source) for d in tower}\n    final = {d: i for i, tower in enumerate(target) for d in tower}\n    disks = set(state)\n    assert disks == set(final) and all(isinstance(i, int) for i in state) and len(source) == len(target) >= 3\n    ans = []\n\n    def move(d, i):  # move disk d to tower i\n        if state[d] == i:\n            return\n        for t in range(3):  # first tower besides i, state[d]\n            if t != i and t != state[d]:\n                break\n        for d2 in range(d + 1, max(disks) + 1):\n            if d2 in disks:\n                move(d2, t)\n        ans.append([state[d], i])\n        state[d] = i\n\n    for d in range(min(disks), max(disks) + 1):\n        if d in disks:\n            move(d, final[d])\n\n    return ans"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Towers of Hanoi](https://en.wikipedia.org/w/index.php?title=Tower_of_Hanoi)\n\nIn this version one must transform a given source state to a target state.",
    "weight": 1.0
  },
  {
    "name": "LongestMonotonicSubstring:0",
    "sat": "def sat(x: List[int], length=13, s=\"Dynamic programming solves this puzzle!!!\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))",
    "ans_type": "List[int]",
    "sol_header": "def sol(length=13, s=\"Dynamic programming solves this puzzle!!!\"):",
    "sol_docstring": "    \"\"\"\n    Remove as few characters as possible from s so that the characters of the remaining string are alphebetical.\n    Here x is the list of string indices that have not been deleted.\n    \"\"\"",
    "sol_bodies": [
      "    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, -1))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[i][2] != -1:\n        i = dyn[i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles.py",
    "notes": "This is a form of the classic\n[Longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) problem\nwhere the goal is to find a substring with characters in sorted order.",
    "weight": 1.0
  },
  {
    "name": "LongestMonotonicSubstringTricky:0",
    "sat": "def sat(x: List[int], length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):\n    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))",
    "ans_type": "List[int]",
    "sol_header": "def sol(length=20, s=\"Dynamic programming solves this classic job-interview puzzle!!!\"):",
    "sol_docstring": "    \"\"\"Find the indices of the longest substring with characters in sorted order\"\"\"",
    "sol_bodies": [
      "    # O(N^2) method. Todo: add binary search solution which is O(n log n)\n    if s == \"\":\n        return []\n    n = len(s)\n    dyn = []  # list of (seq length, seq end, prev index)\n    for i in range(-n, n):\n        try:\n            dyn.append(max((length + 1, i, e) for length, e, _ in dyn if s[e] <= s[i]))\n        except ValueError:\n            dyn.append((1, i, None))  # sequence ends at i\n    _length, i, _ = max(dyn)\n    backwards = [i]\n    while dyn[n + i][2] is not None:\n        i = dyn[n + i][2]\n        backwards.append(i)\n    return backwards[::-1]"
    ],
    "module": "classic_puzzles.py",
    "notes": "The same as the above problem, but with a twist!",
    "weight": 1.0
  },
  {
    "name": "Quine:0",
    "sat": "def sat(quine: str):\n    return eval(quine) == quine",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string that when evaluated as a Python expression is that string itself.\"\"\"",
    "sol_bodies": [
      "    return \"(lambda x: f'({x})({chr(34)}{x}{chr(34)})')(\\\"lambda x: f'({x})({chr(34)}{x}{chr(34)})'\\\")\""
    ],
    "module": "classic_puzzles.py",
    "notes": "[Quine](https://en.wikipedia.org/wiki/Quine_%28computing%29)",
    "weight": 1.0
  },
  {
    "name": "RevQuine:0",
    "sat": "def sat(rev_quine: str):\n    return eval(rev_quine[::-1]) == rev_quine",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string that, when reversed and evaluated gives you back that same string.\"\"\"",
    "sol_bodies": [
      "    return \"rev_quine\"[::-1]  # thanks GPT-3!"
    ],
    "module": "classic_puzzles.py",
    "notes": "Reverse [Quine](https://en.wikipedia.org/wiki/Quine_%28computing%29). The solution we give is from GPT3.",
    "weight": 1.0
  },
  {
    "name": "BooleanPythagoreanTriples:0",
    "sat": "def sat(colors: List[int], n=100):\n    assert set(colors) <= {0, 1} and len(colors) >= n\n    squares = {i ** 2: colors[i] for i in range(1, len(colors))}\n    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=100):",
    "sol_docstring": "    \"\"\"\n    Color the first n integers with one of two colors so that there is no monochromatic Pythagorean triple.\n    A monochromatic Pythagorean triple is a triple of numbers i, j, k such that i^2 + j^2 = k^2 that\n    are all assigned the same color. The input, colors, is a list of 0/1 colors of length >= n.\n    \"\"\"",
    "sol_bodies": [
      "    sqrt = {i * i: i for i in range(1, n)}\n    trips = [(sqrt[i], sqrt[j], sqrt[i + j]) for i in sqrt for j in sqrt if i < j and i + j in sqrt]\n    import random\n    random.seed(0)\n    sol = [random.randrange(2) for _ in range(n)]\n    done = False\n    while not done:\n        done = True\n        random.shuffle(trips)\n        for i, j, k in trips:\n            if sol[i] == sol[j] == sol[k]:\n                done = False\n                sol[random.choice([i, j, k])] = 1 - sol[i]\n    return sol"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Boolean Pythagorean Triples Problem](https://en.wikipedia.org/wiki/Boolean_Pythagorean_triples_problem)",
    "weight": 1.0
  },
  {
    "name": "ClockAngle:0",
    "sat": "def sat(hands: List[int], target_angle=45):\n    h, m = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]",
    "ans_type": "List[int]",
    "sol_header": "def sol(target_angle=45):",
    "sol_docstring": "    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"",
    "sol_bodies": [
      "    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Clock Angle Problem](https://en.wikipedia.org/wiki/Clock_angle_problem), easy variant",
    "weight": 1.0
  },
  {
    "name": "Kirkman:0",
    "sat": "def sat(daygroups: List[List[List[int]]]):\n    assert len(daygroups) == 7\n    assert all(len(groups) == 5 and {i for g in groups for i in g} == set(range(15)) for groups in daygroups)\n    assert all(len(g) == 3 for groups in daygroups for g in groups)\n    return len({(i, j) for groups in daygroups for g in groups for i in g for j in g}) == 15 * 15",
    "ans_type": "List[List[List[int]]]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Arrange 15 people into groups of 3 each day for seven days so that no two people are in the same group twice.\n    \"\"\"",
    "sol_bodies": [
      "    from itertools import combinations\n    import random\n    rand = random.Random(0)\n    days = [[list(range(15)) for _2 in range(2)] for _ in range(7)]  # each day is pi, inv\n    counts = {(i, j): (7 if j in range(k, k + 3) else 0)\n              for k in range(0, 15, 3)\n              for i in range(k, k + 3)\n              for j in range(15) if j != i\n              }\n\n    todos = [pair for pair, count in counts.items() if count == 0]\n    while True:\n        pair = rand.choice(todos)  # choose i and j to make next to each other on some day\n        if rand.randrange(2):\n            pair = pair[::-1]\n\n        a, u = pair\n        pi, inv = rand.choice(days)\n        assert pi[inv[a]] == a and pi[inv[u]] == u\n        bases = [3 * (inv[i] // 3) for i in pair]\n        (b, c), (v, w) = [[x for x in pi[b: b + 3] if x != i] for i, b in zip(pair, bases)]\n        if rand.randrange(2):\n            b, c, = c, b\n        # current (a, b, c) (u, v, w). consider swap of u with b to make (a, u, c) (b, v, w)\n\n        new_pairs = [(a, u), (c, u), (b, v), (b, w)]\n        old_pairs = [(u, v), (u, w), (b, a), (b, c)]\n        gained = sum(counts[p] == 0 for p in new_pairs)\n        lost = sum(counts[p] == 1 for p in old_pairs)\n        if rand.random() <= 100 ** (gained - lost):\n            for p in new_pairs:\n                counts[p] += 1\n                counts[p[::-1]] += 1\n            for p in old_pairs:\n                counts[p] -= 1\n                counts[p[::-1]] -= 1\n            pi[inv[b]], pi[inv[u]], inv[b], inv[u] = u, b, inv[u], inv[b]\n            todos = [pair for pair, count in counts.items() if count == 0]\n            if len(todos) == 0:\n                return [[pi[k:k + 3] for k in range(0, 15, 3)] for pi, _inv in days]"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Kirkman's problem](https://en.wikipedia.org/wiki/Kirkman%27s_schoolgirl_problem)",
    "weight": 1.0
  },
  {
    "name": "MonkeyAndCoconuts:0",
    "sat": "def sat(n: int):\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find the number of coconuts to solve the following riddle:\n        There is a pile of coconuts, owned by five men. One man divides the pile into five equal piles, giving the\n        one left over coconut to a passing monkey, and takes away his own share. The second man then repeats the\n        procedure, dividing the remaining pile into five and taking away his share, as do the third, fourth, and\n        fifth, each of them finding one coconut left over when dividing the pile by five, and giving it to a monkey.\n        Finally, the group divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n        How many coconuts were there in the original pile?\n                                          Quoted from https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts\n    \"\"\"",
    "sol_bodies": [
      "    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5"
    ],
    "module": "classic_puzzles.py",
    "notes": "[The Monkey and the Coconuts](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts)",
    "weight": 1.0
  },
  {
    "name": "No3Colinear:0",
    "sat": "def sat(coords: List[List[int]], side=10, num_points=20):\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(side=10, num_points=20):",
    "sol_docstring": "    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"",
    "sol_bodies": [
      "    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"
    ],
    "module": "classic_puzzles.py",
    "notes": "[No three-in-a-line](https://en.wikipedia.org/wiki/No-three-in-line_problem)",
    "weight": 1.0
  },
  {
    "name": "PostageStamp:0",
    "sat": "def sat(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=80, max_stamps=4, options=[10, 32, 8]):",
    "sol_docstring": "    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"",
    "sol_bodies": [
      "    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Postage stamp problem](https://en.wikipedia.org/wiki/Postage_stamp_problem)",
    "weight": 1.0
  },
  {
    "name": "Sudoku:0",
    "sat": "def sat(x: str, puz=\"____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______\"):\n    assert all(c == \"_\" or c == s for (c, s) in zip(puz, x))\n\n    full = set('123456789')\n    for i in range(9):\n        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, \"invalid row\"\n        assert {x[i] for i in range(i, i + 81, 9)} == full, \"invalid column\"\n        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, \"invalid square\"\n\n    return True",
    "ans_type": "str",
    "sol_header": "def sol(puz=\"____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______\"):",
    "sol_docstring": "    \"\"\"Find the unique valid solution to the Sudoku puzzle\"\"\"",
    "sol_bodies": [
      "    \"\"\"Simple depth-first backtracking solver that branches at the square with fewest possibilities\"\"\"\n    sets = [{int(c)} if c != '_' else set(range(1, 10)) for c in puz]\n\n    groups = []\n    for i in range(9):\n        groups.append(list(range(9 * i, 9 * i + 9)))\n        groups.append(list(range(i, i + 81, 9)))\n        groups.append([9 * a + b + i + 26 * (i % 3) for a in range(3) for b in range(3)])\n\n    inv = [[] for i in range(81)]\n    for g in groups:\n        for i in g:\n            inv[i].append(g)\n\n    def reduce():\n        \"\"\"Reduce possibilities and return False if it's clearly impossible to solve, True otherwise.\n        Repeatedly applies two types of logic:\n        * When an entry has a single possibility, remove that value from all 20 neighbors\n        * When a row/col/square has only one entry with k as a possibility, fill in that possibility\n        \"\"\"\n        done = False\n        while not done:\n            done = True\n            for i in range(81):\n                new = sets[i] - {k for g in inv[i] for j in g if j != i and len(sets[j]) == 1 for k in sets[j]}\n                if not new:\n                    return False\n                if len(sets[i]) != len(new):\n                    sets[i] = new\n                    done = False\n\n            for g in groups:\n                for k in range(1, 10):\n                    possibilities = [i for i in g if k in sets[i]]\n                    if not possibilities:\n                        return False\n                    if len(possibilities) == 1:\n                        i = possibilities[0]\n                        if len(sets[i]) > 1:\n                            done = False\n                            sets[i] = {k}\n\n        return True\n\n    ans = []\n\n    counter = 0\n\n    def solve_helper():\n        nonlocal sets, ans, counter\n        counter += 1\n        assert len(ans) <= 1, \"Sudoku puzzle should have a unique solution\"\n        old_sets = sets[:]\n        if reduce():\n            if all(len(s) == 1 for s in sets):\n                ans.append(\"\".join(str(list(s)[0]) for s in sets))\n            else:\n                smallest_set = min(range(81), key=lambda i: len(sets[i]) if len(sets[i]) > 1 else 10)\n                for v in sorted(sets[smallest_set]):\n                    sets[smallest_set] = {v}\n                    solve_helper()\n\n        sets = old_sets\n\n    solve_helper()\n    assert ans, \"No solution found\"\n    return ans[0]"
    ],
    "module": "classic_puzzles.py",
    "notes": "The classic game of [Sudoku](https://en.wikipedia.org/wiki/Sudoku)",
    "weight": 1.0
  },
  {
    "name": "SquaringTheSquare:0",
    "sat": "def sat(xy_sides: List[List[int]]):\n    n = max(x + side for x, y, side in xy_sides)\n    assert len({side for x, y, side in xy_sides}) == len(xy_sides) > 1\n    for x, y, s in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for x2, y2, s2 in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or y2 >= y + s or y2 + s2 <= y\n\n    return sum(side ** 2 for x, y, side in xy_sides) == n ** 2",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Partition a square into smaller squares with unique side lengths. A perfect squared path has distinct sides.\n    xy_sides is a List of (x, y, side)\n    \"\"\"",
    "sol_bodies": [
      "    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Squaring the square](https://en.wikipedia.org/wiki/Squaring_the_square)\nWikipedia gives a minimal [solution with 21 squares](https://en.wikipedia.org/wiki/Squaring_the_square)\ndue to Duijvestijn (1978).",
    "weight": 1.0
  },
  {
    "name": "NecklaceSplit:0",
    "sat": "def sat(n: int, lace=\"bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb\"):\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")",
    "ans_type": "int",
    "sol_header": "def sol(lace=\"bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb\"):",
    "sol_docstring": "    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"",
    "sol_bodies": [
      "    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Necklace Splitting Problem](https://en.wikipedia.org/wiki/Necklace_splitting_problem)",
    "weight": 1.0
  },
  {
    "name": "PandigitalSquare:0",
    "sat": "def sat(n: int):\n    s = str(n * n)\n    for i in \"0123456789\":\n        assert s.count(i) == 1\n    return True",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find an integer whose square has all digits 0-9 once.\"\"\"",
    "sol_bodies": [
      "    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Square",
    "weight": 1.0
  },
  {
    "name": "AllPandigitalSquares:0",
    "sat": "def sat(nums: List[int]):\n    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find all 174 integers whose 10-digit square has all digits 0-9 just once.\"\"\"",
    "sol_bodies": [
      "    return [i for i in range(-10 ** 5, 10 ** 5) if sorted([int(s) for s in str(i * i)]) == list(range(10))]"
    ],
    "module": "classic_puzzles.py",
    "notes": "All [Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Squares",
    "weight": 1.0
  },
  {
    "name": "CardGame24:0",
    "sat": "def sat(expr: str, nums=[3, 7, 3, 7]):\n    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, \"hint: nums is a list of four ints in 1..13\"\n    expr = expr.replace(\" \", \"\")  # ignore whitespace\n    digits = \"\"\n    for i in range(len(expr)):\n        if i == 0 or expr[i - 1] in \"+*-/(\":\n            assert expr[i] in \"123456789(\", \"Expr cannot contain **, //, or unary -\"\n        assert expr[i] in \"1234567890()+-*/\", \"Expr can only contain `0123456789()+-*/`\"\n        digits += expr[i] if expr[i] in \"0123456789\" else \" \"\n    assert sorted(int(s) for s in digits.split()) == sorted(nums), \"Each number must occur exactly once\"\n    return abs(eval(expr) - 24.0) < 1e-6",
    "ans_type": "str",
    "sol_header": "def sol(nums=[3, 7, 3, 7]):",
    "sol_docstring": "    \"\"\"Find a formula with two 3's and two 7's and + - * / (and parentheses) that evaluates to 24.\"\"\"",
    "sol_bodies": [
      "    def helper(pairs):\n        if len(pairs) == 2:\n            (x, s), (y, t) = pairs\n            ans = {\n                x + y: f\"{s}+{t}\",\n                x - y: f\"{s}-({t})\",\n                y - x: f\"{t}-({s})\",\n                x * y: f\"({s})*({t})\"\n            }\n            if y != 0:\n                ans[x / y] = f\"({s})/({t})\"\n            if x != 0:\n                ans[y / x] = f\"({t})/({s})\"\n            return ans\n        ans = {y: t\n               for i in range(len(pairs))\n               for x_s in helper(pairs[:i] + pairs[i + 1:]).items()\n               for y, t in helper([x_s, pairs[i]]).items()}\n        if len(pairs) == 3:\n            return ans\n        ans.update({z: u\n                    for i in range(1, 4)\n                    for x_s in helper([pairs[0], pairs[i]]).items()\n                    for y_t in helper(pairs[1:i] + pairs[i + 1:]).items()\n                    for z, u in helper([x_s, y_t]).items()\n                    })\n        return ans\n\n    derivations = helper([(n, str(n)) for n in nums])\n    for x in derivations:\n        if abs(x - 24.0) < 1e-6:\n            return derivations[x]"
    ],
    "module": "classic_puzzles.py",
    "notes": "[24 Game](https://en.wikipedia.org/wiki/24_Game)\n\nIn this game one is given four numbers from the range 1-13 (Ace-King) and one needs to combine them with\n    + - * / (and parentheses)\nto make the number 24.\nThe solution to this tricky example is `7 * (3 + 3 / 7)`",
    "weight": 1.0
  },
  {
    "name": "Easy63:0",
    "sat": "def sat(s: str):\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 2 and s.count(\"1\") == 1 and eval(s) == 63",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a formula using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"",
    "sol_bodies": [
      "    return \"8*8-1\""
    ],
    "module": "classic_puzzles.py",
    "notes": "An easy puzzle to make 63 using two 8's and one 1's.",
    "weight": 1.0
  },
  {
    "name": "Harder63:0",
    "sat": "def sat(s: str):\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 3 and s.count(\"1\") == 1 and eval(s) == 63",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find an expression using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"",
    "sol_bodies": [
      "    return \"8*8-1**8\""
    ],
    "module": "classic_puzzles.py",
    "notes": "An harder puzzle to make 63 using three 8's and one 1's.",
    "weight": 1.0
  },
  {
    "name": "WaterPouring:0",
    "sat": "def sat(moves: List[List[int]], capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]):",
    "sol_docstring": "    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"",
    "sol_bodies": [
      "    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Water pouring puzzle](https://en.wikipedia.org/w/index.php?title=Water_pouring_puzzle&oldid=985741928)",
    "weight": 1.0
  },
  {
    "name": "VerbalArithmetic:0",
    "sat": "def sat(li: List[int], words=['SEND', 'MORE', 'MONEY']):\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]",
    "ans_type": "List[int]",
    "sol_header": "def sol(words=['SEND', 'MORE', 'MONEY']):",
    "sol_docstring": "    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"",
    "sol_bodies": [
      "    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"
    ],
    "module": "classic_puzzles.py",
    "notes": "Find a substitution of digits for characters to make the numbers add up in a sum like this:\nSEND + MORE = MONEY\n\nThe first digit in any number cannot be 0. In this example the solution is `9567 + 1085 = 10652`.\nSee [Wikipedia article](https://en.wikipedia.org/wiki/Verbal_arithmetic)",
    "weight": 1.0
  },
  {
    "name": "SlidingPuzzle:0",
    "sat": "def sat(moves: List[int], start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):\n\n    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank\n    for i in moves:\n        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1\n        locs[0], locs[i] = locs[i], locs[0]\n    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)",
    "ans_type": "List[int]",
    "sol_header": "def sol(start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):",
    "sol_docstring": "    \"\"\"\n    In this puzzle, you are given a board like:\n    1 2 5\n    3 4 0\n    6 7 8\n\n    and your goal is to transform it to:\n    0 1 2\n    3 4 5\n    6 7 8\n\n    by a sequence of swaps with the 0 square (0 indicates blank). The starting configuration is given by a 2d list\n    of lists and the answer is represented by a list of integers indicating which number you swap with 0. In the\n    above example, an answer would be [1, 2, 5]\n    \"\"\"",
    "sol_bodies": [
      "    from collections import defaultdict\n    import math\n    d = len(start)\n    N = d * d\n    assert all(len(row) == d for row in start)\n\n    def get_state(\n            li):  # state is an integer with 4 bits for each slot and the last 4 bits indicate where the blank is\n        ans = 0\n        for i in li[::-1] + [li.index(0)]:\n            ans = (ans << 4) + i\n        return ans\n\n    start = get_state([i for row in start for i in row])\n    target = get_state(list(range(N)))\n\n    def h(state):  # manhattan distance\n        ans = 0\n        for i in range(N):\n            state = (state >> 4)\n            n = state & 15\n            if n != 0:\n                ans += abs(i % d - n % d) + abs(i // d - n // d)\n        return ans\n\n    g = defaultdict(lambda: math.inf)\n    g[start] = 0  # shortest p ath lengths\n    f = {start: h(start)}  # f[s] = g[s] + h(s)\n    backtrack = {}\n\n    todo = {start}\n    import heapq\n    heap = [(f[start], start)]\n\n    neighbors = [[i for i in [b - 1, b + 1, b + d, b - d] if i in range(N) and (b // d == i // d or b % d == i % d)]\n                 for b in range(N)]\n\n    def next_state(s, blank, i):\n        assert blank == (s & 15)\n        v = (s >> (4 * i + 4)) & 15\n        return s + (i - blank) + (v << (4 * blank + 4)) - (v << (4 * i + 4))\n\n    while todo:\n        (dist, s) = heapq.heappop(heap)\n        if f[s] < dist:\n            continue\n        if s == target:\n            # compute path\n            ans = []\n            while s != start:\n                s, i = backtrack[s]\n                ans.append((s >> (4 * i + 4)) & 15)\n            return ans[::-1]\n\n        todo.remove(s)\n\n        blank = s & 15\n        score = g[s] + 1\n        for i in neighbors[blank]:\n            s2 = next_state(s, blank, i)\n\n            if score < g[s2]:\n                # paths[s2] = paths[s] + [s[i]]\n                g[s2] = score\n                backtrack[s2] = (s, i)\n                score2 = score + h(s2)\n                f[s2] = score2\n                todo.add(s2)\n                heapq.heappush(heap, (score2, s2))"
    ],
    "module": "classic_puzzles.py",
    "notes": "[Sliding puzzle](https://en.wikipedia.org/wiki/15_puzzle)\nThe 3-, 8-, and 15-sliding puzzles are classic examples of A* search.\nThe problem is NP-hard but the puzzles can all be solved with A* and an efficient representation.",
    "weight": 1.0
  },
  {
    "name": "FindCloseElements:0",
    "sat": "def sat(pair: List[float], nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):\n    a, b = pair\n    assert a in nums and b in nums and a != b\n    return abs(a - b) == min(x - y for x in nums for y in nums if x > y)",
    "ans_type": "List[float]",
    "sol_header": "def sol(nums=[0.17, 21.3, 5.0, 9.0, 11.0, 4.99, 17.0, 17.0, 12.4, 6.8]):",
    "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the two closest distinct numbers in the list.\n\n    Sample Input:\n    [1.2, 5.23, 0.89, 21.0, 5.28, 1.2]\n\n    Sample Output:\n    [5.23, 5.28]\n    \"\"\"",
    "sol_bodies": [
      "    s = sorted(set(nums))\n    return min([[a, b] for a, b in zip(s, s[1:])], key=lambda x: x[1] - x[0])"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#0",
    "weight": 1.0
  },
  {
    "name": "SeparateParenGroups:0",
    "sat": "def sat(ls: List[str], combined=\"() (()) ((() () ())) (() )\"):\n    for s in ls:\n        assert s.count(\"(\") == s.count(\")\")\n        assert all(s[:i].count(\"(\") > s[:i].count(\")\") for i in range(1, len(s)))  # s is not further divisible\n    return ''.join(ls) == combined.replace(' ', '')",
    "ans_type": "List[str]",
    "sol_header": "def sol(combined=\"() (()) ((() () ())) (() )\"):",
    "sol_docstring": "    \"\"\"\n    Given a string consisting of whitespace and groups of matched parentheses, split it\n    into groups of perfectly matched parentheses without any whitespace.\n\n    Sample Input:\n    '( ()) ((()()())) (()) ()'\n\n    Sample Output:\n    ['(())', '((()()()))', '(())', '()']\n    \"\"\"",
    "sol_bodies": [
      "    cur = ''\n    ans = []\n    depth = 0\n    for c in combined.replace(' ', ''):\n        cur += c\n        if c == '(':\n            depth += 1\n        else:\n            assert c == ')'\n            depth -= 1\n            if depth == 0:\n                ans.append(cur)\n                cur = ''\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#1",
    "weight": 1.0
  },
  {
    "name": "Frac:0",
    "sat": "def sat(x: float, v=523.12892):\n    return 0 <= x < 1 and (v - x).is_integer()",
    "ans_type": "float",
    "sol_header": "def sol(v=523.12892):",
    "sol_docstring": "    \"\"\"\n    Given a floating point number, find its fractional part.\n\n    Sample Input:\n    4.175\n\n    Sample Output:\n    0.175\n    \"\"\"",
    "sol_bodies": [
      "    return v % 1.0"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#2",
    "weight": 1.0
  },
  {
    "name": "FirstNegCumulative:0",
    "sat": "def sat(firsts: List[int], balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):\n    for i, bals in enumerate(balances):\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                assert total == firsts[i]\n                break\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):",
    "sol_docstring": "    \"\"\"\n    Given a list of numbers which represent bank deposits and withdrawals, find the *first* negative balance.\n\n    Sample Input:\n    [[12, -5, 3, -99, 14, 88, -99], [-1, 2, 5]]\n\n    Sample Output:\n    [-89, -1]\n    \"\"\"",
    "sol_bodies": [
      "    firsts = []\n    for bals in balances:\n        total = 0\n        for b in bals:\n            total += b\n            if total < 0:\n                firsts.append(total)\n                break\n    return firsts"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#3",
    "weight": 1.0
  },
  {
    "name": "MinSquaredDeviation:0",
    "sat": "def sat(x: float, nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):\n    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4",
    "ans_type": "float",
    "sol_header": "def sol(nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):",
    "sol_docstring": "    \"\"\"\n    Given a list of numbers, find x that minimizes mean squared deviation.\n\n    Sample Input:\n    [4, -5, 17, -9, 14, 108, -9]\n\n    Sample Output:\n    17.14285\n    \"\"\"",
    "sol_bodies": [
      "    return sum(nums) / len(nums)  # mean minimizes mean squared deviation"
    ],
    "module": "human_eval.py",
    "notes": "Loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#4\n\nThe HumanEval problem was simply to compute the mean absolute deviation. This problem is more interesting.\nIt requires minimizing the sum of squared deviations, which turns out to be the mean `mu`. Moreover, if\n`mu` is the mean of the numbers then a simple calculation shows that:\n\n`sum((mu - n) ** 2 for n in nums) == sum((m - n) ** 2 for m in nums for n in nums) / (2 * len(nums))`\n\nWe use 0.501 rather than 1/2 to deal with rounding errors.",
    "weight": 1.0
  },
  {
    "name": "Intersperse:0",
    "sat": "def sat(li: List[int], nums=[12, 23, -2, 5, 0], sep=4):\n    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[12, 23, -2, 5, 0], sep=4):",
    "sol_docstring": "    \"\"\"\n    Given a list of numbers and a number to inject, create a list containing that number in between each pair of\n    adjacent numbers.\n\n    Sample Input:\n    [8, 14, 21, 17, 9, -5], 3\n\n    Sample Output:\n    [8, 3, 14, 3, 21, 3, 17, 3, 9, 3, -5]\n    \"\"\"",
    "sol_bodies": [
      "    ans = [sep] * (2 * len(nums) - 1)\n    ans[::2] = nums\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#5",
    "weight": 1.0
  },
  {
    "name": "DeepestParens:0",
    "sat": "def sat(depths: List[int], parens=\"() (()) ((()()())) (((((((())))))))\"):\n    groups = parens.split()\n    for depth, group in zip(depths, groups):\n        budget = depth\n        success = False\n        for c in group:\n            if c == '(':\n                budget -= 1\n                if budget == 0:\n                    success = True\n                assert budget >= 0\n            else:\n                assert c == ')'\n                budget += 1\n        assert success\n\n    return len(groups) == len(depths)",
    "ans_type": "List[int]",
    "sol_header": "def sol(parens=\"() (()) ((()()())) (((((((())))))))\"):",
    "sol_docstring": "    \"\"\"\n    Given a string consisting of groups of matched nested parentheses separated by parentheses,\n    compute the depth of each group.\n\n    Sample Input:\n    '(()) ((()()())) (()) ()'\n\n    Sample Output:\n    [2, 3, 2, 1]\n    \"\"\"",
    "sol_bodies": [
      "    def max_depth(s):\n        m = 0\n        depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                m = max(m, depth)\n            else:\n                assert c == ')'\n                depth -= 1\n        assert depth == 0\n        return m\n\n    return [max_depth(s) for s in parens.split()]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#6",
    "weight": 1.0
  },
  {
    "name": "FindContainers:0",
    "sat": "def sat(containers: List[str], strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):\n    i = 0\n    for s in strings:\n        if substring in s:\n            assert containers[i] == s\n            i += 1\n    return i == len(containers)",
    "ans_type": "List[str]",
    "sol_header": "def sol(strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring=\"at\"):",
    "sol_docstring": "    \"\"\"\n    Find the strings in a list containing a given substring\n\n    Sample Input:\n    ['cat', 'dog', 'bear'], 'a'\n\n    Sample Output:\n    ['cat', 'bear']\n    \"\"\"",
    "sol_bodies": [
      "    return [s for s in strings if substring in s]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#7",
    "weight": 1.0
  },
  {
    "name": "SumProduct:0",
    "sat": "def sat(nums: List[int], tot=14, prod=99):\n    assert sum(nums) == tot\n    p = 1\n    for n in nums:\n        p *= n\n    return p == prod",
    "ans_type": "List[int]",
    "sol_header": "def sol(tot=14, prod=99):",
    "sol_docstring": "    \"\"\"\n    Find a list of numbers with a given sum and a given product.\n\n    Sample Input:\n    12, 32\n\n    Sample Output:\n    [2, 8, 2]\n    \"\"\"",
    "sol_bodies": [
      "    ans = [prod]\n    while sum(ans) > tot:\n        ans += [-1, -1]\n    ans += [1] * (tot - sum(ans))\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#8",
    "weight": 1.0
  },
  {
    "name": "RollingMax:0",
    "sat": "def sat(maxes: List[int], nums=[1, 4, 3, -6, 19]):\n    assert len(maxes) == len(nums)\n    for i in range(len(nums)):\n        if i > 0:\n            assert maxes[i] == max(maxes[i - 1], nums[i])\n        else:\n            assert maxes[0] == nums[0]\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[1, 4, 3, -6, 19]):",
    "sol_docstring": "    \"\"\"\n    Find a list whose ith element is the maximum of the first i elements of the input list.\n\n    Sample Input:\n    [2, 8, 2]\n\n    Sample Output:\n    [2, 8, 8]\n    \"\"\"",
    "sol_bodies": [
      "    return [max(nums[:i]) for i in range(1, len(nums) + 1)]",
      "    ans = []\n    if nums:\n        m = nums[0]\n        for n in nums:\n            m = max(n, m)\n            ans.append(m)\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#9",
    "weight": 1.0
  },
  {
    "name": "PalindromeContaining:0",
    "sat": "def sat(ans: str, s=\"so easy\", length=20):\n    return ans == ans[::-1] and len(ans) == length and s in ans",
    "ans_type": "str",
    "sol_header": "def sol(s=\"so easy\", length=20):",
    "sol_docstring": "    \"\"\"\n    Find a palindrome of a given length containing a given string.\n\n    Sample Input:\n    \"abba\", 6\n\n    Sample Output:\n    \"cabbac\"\n    \"\"\"",
    "sol_bodies": [
      "    ls = list(s)\n    for i in range(length - len(s) + 1):\n        arr = ['x'] * length\n        arr[i:i + len(s)] = ls\n        a = length - i - 1\n        b = length - (i + len(s)) - 1\n        if b == -1:\n            b = None\n        arr[a:b:-1] = ls\n        if arr == arr[::-1]:\n            ans = \"\".join(arr)\n            if s in ans:\n                return ans\n    assert False, \"shouldn't reach here\""
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#10",
    "weight": 1.0
  },
  {
    "name": "BinaryStrXOR:0",
    "sat": "def sat(str_num: str, nums=['100011101100001', '100101100101110']):\n    a, b = nums\n    return int(str_num, 2) == int(a, 2) ^ int(b, 2)",
    "ans_type": "str",
    "sol_header": "def sol(nums=['100011101100001', '100101100101110']):",
    "sol_docstring": "    \"\"\"\n    Find a the XOR of two given strings interpreted as binary numbers.\n\n    Sample Input:\n    \"0001\", \"1011\"\n\n    Sample Output:\n    \"1010\"\n    \"\"\"",
    "sol_bodies": [
      "    a, b = nums\n    ans = int(a, 2) ^ int(b, 2)\n    return format(ans, \"b\")"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#11",
    "weight": 1.0
  },
  {
    "name": "LongestStr:0",
    "sat": "def sat(ans: str, words=['these', 'are', 'some', 'pretty', 'long', 'words']):\n    return ans in words and all(len(ans) >= len(w) for w in words)",
    "ans_type": "str",
    "sol_header": "def sol(words=['these', 'are', 'some', 'pretty', 'long', 'words']):",
    "sol_docstring": "    \"\"\"\n    Find the longest of a list of strings\n\n    Sample Input:\n    [\"cat\", \"dog\", \"sheep\", \"chimp\"]\n\n    Sample Output:\n    \"sheep\"\n    \"\"\"",
    "sol_bodies": [
      "    return max(words, key=len)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#12",
    "weight": 1.0
  },
  {
    "name": "CertifiedGCD:0",
    "sat": "def sat(ans: List[int], m=200004931, n=66679984):\n    gcd, a, b = ans\n    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0",
    "ans_type": "List[int]",
    "sol_header": "def sol(m=200004931, n=66679984):",
    "sol_docstring": "    \"\"\"\n    Find the greatest common divisor of two integers m, n and a certificate a, b such that m*a + n*b = gcd\n\n    Sample Input:\n    20, 30\n\n    Sample Output:\n    10, -1, 1\n    \"\"\"",
    "sol_bodies": [
      "    \"\"\"\n    Derivation of solution below\n    Recursive solution guarantees a * (big % small) + b * small == gcd\n    Let d = big // small so (big % small) == big - small * d\n    gives a * (big - small * d) + b * small == gcd\n    or equivalently (b - a * d) * small + a * big == gcd\n    \"\"\"\n\n    def gcd_cert(small, big):\n        \"\"\"Returns gcd, a, b, such that small * a + big * b == gcd\"\"\"\n        assert 0 < small <= big\n        if big % small == 0:\n            return [small, 1, 0]\n        gcd, a, b = gcd_cert(big % small, small)\n        return [gcd, b - a * (big // small), a]\n\n    if m < n:\n        return gcd_cert(m, n)\n    gcd, a, b = gcd_cert(n, m)\n    return [gcd, b, a]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#13",
    "weight": 1.0
  },
  {
    "name": "AllPrefixes:0",
    "sat": "def sat(prefixes: List[str], s=\"donesezichethofalij\"):\n    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)",
    "ans_type": "List[str]",
    "sol_header": "def sol(s=\"donesezichethofalij\"):",
    "sol_docstring": "    \"\"\"\n    Find all prefixes of a given string\n\n    Sample Input:\n    \"aabcd\"\n\n    Sample Output:\n    [\"\", \"a\", \"aa\", \"aab\", \"aabc\", \"aabcd\"]\n    \"\"\"",
    "sol_bodies": [
      "    return [s[:i] for i in range(len(s) + 1)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#14",
    "weight": 1.0
  },
  {
    "name": "SpaceyRange:0",
    "sat": "def sat(ans: str, n=15):\n    return [int(i) for i in ans.split(' ')] == list(range(n + 1))",
    "ans_type": "str",
    "sol_header": "def sol(n=15):",
    "sol_docstring": "    \"\"\"\n    Find a string consisting of the non-negative integers up to n inclusive\n\n    Sample Input:\n    4\n\n    Sample Output:\n    '0 1 2 3 4'\n    \"\"\"",
    "sol_bodies": [
      "    return ' '.join(str(i) for i in range(n + 1))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#15",
    "weight": 1.0
  },
  {
    "name": "DistinctChars:0",
    "sat": "def sat(ans: List[str], s=\"The quick brown fox jumps over the lazy dog!\", n=28):\n    assert all(ans.count(c.lower()) == 1 for c in s)\n    assert all(c == c.lower() for c in ans)\n    assert all(c in s.lower() for c in ans)\n    return True",
    "ans_type": "List[str]",
    "sol_header": "def sol(s=\"The quick brown fox jumps over the lazy dog!\", n=28):",
    "sol_docstring": "    \"\"\"\n    Find the set of distinct characters in a string, ignoring case\n\n    Sample Input:\n    'HELlo', 4\n\n    Sample Output:\n    ['h', 'e', 'l', 'o']\n    \"\"\"",
    "sol_bodies": [
      "    return list(set(s.lower()))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#16",
    "weight": 1.0
  },
  {
    "name": "ParseMusic:0",
    "sat": "def sat(beats: List[int], score=\"o o o| o| .| .| .| o| o| o o o| .|\"):\n    return \" \".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score",
    "ans_type": "List[int]",
    "sol_header": "def sol(score=\"o o o| o| .| .| .| o| o| o o o| .|\"):",
    "sol_docstring": "    \"\"\"\n    Parse a string of notes to beats, 'o'=4, 'o|'=2, '.|'=1\n\n    Example input:\n    'o o .| o|'\n\n    Example output:\n    [4, 4, 1, 2]\n    \"\"\"",
    "sol_bodies": [
      "    mapping = {'.|': 1, 'o|': 2, 'o': 4}\n    return [mapping[note] for note in score.split()]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#17",
    "weight": 1.0
  },
  {
    "name": "OverlappingCount:0",
    "sat": "def sat(ans: List[int], s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):\n    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count",
    "ans_type": "List[int]",
    "sol_header": "def sol(s=\"Bananannanaannanaanananananana\", sub=\"anan\", count=7):",
    "sol_docstring": "    \"\"\"\n    Find occurrences of a substring in a parent string *including overlaps*\n\n    Sample Input:\n    'helllo', 'll'\n\n    Sample Output:\n    [2, 3]\n    \"\"\"",
    "sol_bodies": [
      "    ans = []\n    for i in range(len(s) + 1):\n        if s[i:i + len(sub)] == sub:\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#18",
    "weight": 1.0
  },
  {
    "name": "SortNumbers:0",
    "sat": "def sat(ans: str, s=\"six one four three two nine eight\"):\n    nums = 'zero one two three four five six seven eight nine'.split()\n    return [nums.index(x) for x in ans.split(\" \")] == sorted([nums.index(x) for x in s.split(\" \")])",
    "ans_type": "str",
    "sol_header": "def sol(s=\"six one four three two nine eight\"):",
    "sol_docstring": "    \"\"\"\n    Sort numbers based on strings\n\n    Sample input\n    ---\n    \"six one four\"\n\n    Sample output\n    ---\n    \"one four six\"\n    \"\"\"",
    "sol_bodies": [
      "    nums = 'zero one two three four five six seven eight nine'.split()\n    arr = [nums.index(x) for x in s.split()]\n    arr.sort()\n    ans = \" \".join([nums[i] for i in arr])\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#19",
    "weight": 1.0
  },
  {
    "name": "FindClosePair:0",
    "sat": "def sat(inds: List[int], nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):\n    a, b = inds\n    assert a != b and a >= 0 and b >= 0\n    for i in range(len(nums)):\n        for j in range(i):\n            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):",
    "sol_docstring": "    \"\"\"\n    Given a list of numbers, find the indices of the closest pair.\n\n    Sample Input:\n    [1.2, 5.25, 0.89, 21.0, 5.23]\n\n    Sample Output:\n    [4, 1]\n    \"\"\"",
    "sol_bodies": [
      "    best = [0, 1]\n    best_score = abs(nums[1] - nums[0])\n    for i in range(len(nums)):\n        for j in range(i):\n            score = abs(nums[i] - nums[j])\n            if score < best_score:\n                best_score = score\n                best = [i, j]\n    return best"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#20",
    "weight": 1.0
  },
  {
    "name": "Rescale:0",
    "sat": "def sat(ans: List[float], nums=[13.0, 17.0, 17.0, 15.5, 2.94]):\n    assert min(ans) == 0.0 and max(ans) == 1.0\n    a = min(nums)\n    b = max(nums)\n    for i in range(len(nums)):\n        x = a + (b - a) * ans[i]\n        assert abs(nums[i] - x) < 1e-6\n    return True",
    "ans_type": "List[float]",
    "sol_header": "def sol(nums=[13.0, 17.0, 17.0, 15.5, 2.94]):",
    "sol_docstring": "    \"\"\"\n    Rescale and shift numbers so that they cover the range [0, 1]\n\n    Sample input\n    ---\n    [18.5, 17.0, 18.0, 19.0, 18.0]\n\n    Sample output\n    ---\n    [0.75, 0.0, 0.5, 1.0, 0.5]\n    \"\"\"",
    "sol_bodies": [
      "    nums = nums.copy()\n\n    a = min(nums)\n    b = max(nums)\n    if b - a == 0:\n        return [0.0] + [1.0] * (len(nums) - 1)\n    for i in range(len(nums)):\n        nums[i] = (nums[i] - a) / (b - a)\n    return nums"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#21",
    "weight": 1.0
  },
  {
    "name": "FilterInts:0",
    "sat": "def sat(candidates: List[str], int_indices=[2, 4, 7, 9, 101]):\n    for i in int_indices:\n        int(candidates[i])\n    for i, s in enumerate(candidates):\n        if i not in int_indices:\n            try:\n                int(s)\n                return False\n            except ValueError:\n                pass\n    return True",
    "ans_type": "List[str]",
    "sol_header": "def sol(int_indices=[2, 4, 7, 9, 101]):",
    "sol_docstring": "    \"\"\"\n    Find a list of strings where the only valid integers are at the given indices\n\n    Sample input\n    ---\n    [2, 4, 5]\n\n    Sample output\n    ---\n    [\"cat\", \"2.7\", \"2\", \"\", \"3\", \"-17\", \"free\"]\n    \"\"\"",
    "sol_bodies": [
      "    if not int_indices:\n        return []\n    ans = [\"\"] * (1 + max(abs(i) for i in int_indices))\n    for i in int_indices:\n        ans[i] = \"17\"\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#22",
    "weight": 1.0
  },
  {
    "name": "StrLength:0",
    "sat": "def sat(lengths: List[int], strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):\n    for length, s in zip(lengths, strs):\n        try:\n            s[length]\n            return False\n        except IndexError:\n            s[length - 1]\n    return len(lengths) == len(strs)",
    "ans_type": "List[int]",
    "sol_header": "def sol(strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):",
    "sol_docstring": "    \"\"\"\n    Find the lengths of a list of non-empty strings\n\n    Sample input\n    ---\n    [\"foo\", \"bars\"]\n\n    Sample output\n    ---\n    [3, 4]\n    \"\"\"",
    "sol_bodies": [
      "    return [len(s) for s in strs]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#23",
    "weight": 1.0
  },
  {
    "name": "LargestDivisor:0",
    "sat": "def sat(d: int, n=123456):\n    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))",
    "ans_type": "int",
    "sol_header": "def sol(n=123456):",
    "sol_docstring": "    \"\"\"\n    Find the largest integer divisor of a number n that is less than n\n\n    Sample input\n    ---\n    1000\n\n    Sample output\n    ---\n    500\n    \"\"\"",
    "sol_bodies": [
      "    return next(d for d in range(n - 1, 0, -1) if n % d == 0)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#24",
    "weight": 1.0
  },
  {
    "name": "PrimeFactorization:0",
    "sat": "def sat(factors: List[int], n=123456, num_factors=8):\n    assert len(factors) == num_factors\n    prod = 1\n    for d in factors:\n        prod *= d\n        assert d > 1\n    return prod == n",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=123456, num_factors=8):",
    "sol_docstring": "    \"\"\"\n    Factor number n into a given number of non-trivial factors\n\n    Sample input\n    ---\n    1000, 6\n\n    Sample output\n    ---\n    [2, 2, 2, 5, 5, 5]\n    \"\"\"",
    "sol_bodies": [
      "    if num_factors == 0:\n        return []\n    if num_factors == 1:\n        return [n]\n    ans = []\n    for d in range(2, n):\n        while n % d == 0:\n            n //= d\n            ans.append(d)\n            if len(ans) == num_factors - 1:\n                ans.append(n)\n                return ans\n    assert False"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#25",
    "weight": 1.0
  },
  {
    "name": "Dedup:0",
    "sat": "def sat(ans: List[int], li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):\n    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))",
    "ans_type": "List[int]",
    "sol_header": "def sol(li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):",
    "sol_docstring": "    \"\"\"\n    Remove duplicates from a list of integers, preserving order\n\n    Sample input\n    ---\n    [1, 3, 2, 9, 2, 1, 55]\n\n    Sample output\n    ---\n    [1, 3, 2, 9, 55]\n    \"\"\"",
    "sol_bodies": [
      "    seen = set()\n    ans = []\n    for n in li:\n        if n not in seen:\n            ans.append(n)\n            seen.add(n)\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#26",
    "weight": 1.0
  },
  {
    "name": "FlipCase:0",
    "sat": "def sat(ans: str, s=\"FlIp ME!\"):\n    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))",
    "ans_type": "str",
    "sol_header": "def sol(s=\"FlIp ME!\"):",
    "sol_docstring": "    \"\"\"\n    Flip case\n\n    Sample input\n    ---\n    'cAt'\n\n    Sample output\n    ---\n    'CaT'\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(c.lower() if c.upper() == c else c.upper() for c in s)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#27",
    "weight": 1.0
  },
  {
    "name": "CatStrings:0",
    "sat": "def sat(cat: str, strings=['Will', 'i', 'am', 'Now', 'here']):\n    i = 0\n    for s in strings:\n        for c in s:\n            assert cat[i] == c\n            i += 1\n    return i == len(cat)",
    "ans_type": "str",
    "sol_header": "def sol(strings=['Will', 'i', 'am', 'Now', 'here']):",
    "sol_docstring": "    \"\"\"\n    Concatenate a list of strings\n\n    Sample input\n    ---\n    ['cat', 'dog', 'bird']\n\n    Sample output\n    ---\n    'catdogbird'\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(strings)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#28",
    "weight": 1.0
  },
  {
    "name": "FindExtensions:0",
    "sat": "def sat(extensions: List[str], strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):\n    i = 0\n    for s in strings:\n        if s.startswith(prefix):\n            assert extensions[i] == s\n            i += 1\n    return i == len(extensions)",
    "ans_type": "List[str]",
    "sol_header": "def sol(strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix=\"do\"):",
    "sol_docstring": "    \"\"\"\n    Find the strings in a list starting with a given prefix\n\n    Sample Input:\n    ['cat', 'car', 'fear', 'center'], 'ca'\n\n    Sample Output:\n    ['cat', 'car']\n    \"\"\"",
    "sol_bodies": [
      "    return [s for s in strings if s.startswith(prefix)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#29",
    "weight": 1.0
  },
  {
    "name": "FindPositives:0",
    "sat": "def sat(positives: List[int], nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):\n    stack = positives[::-1]\n    for n in nums:\n        assert n <= 0 or n == stack.pop()\n    return stack == []",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):",
    "sol_docstring": "    \"\"\"\n    Find the positive integers in a list\n\n    Sample Input:\n    [-1, 3, 19, -2, 0, 44, 0, 44, 11]\n\n    Sample Output:\n    [3, 19, 44, 44, 11]\n    \"\"\"",
    "sol_bodies": [
      "    return [i for i in nums if i > 0]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#30",
    "weight": 1.0
  },
  {
    "name": "FermatComposites:0",
    "sat": "def sat(certificates: List[int], nums=[1449, 14, 21, 105, 217]):\n    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[1449, 14, 21, 105, 217]):",
    "sol_docstring": "    \"\"\"\n    Find Fermat composite certificates for a list of numbers > 1\n\n    Sample Input:\n    [1469]\n\n    Sample Output:\n    [3]  # because (3 ** 1468) % 1469 != 1\n    \"\"\"",
    "sol_bodies": [
      "    return [next(i for i in range(2, n) if pow(i, n - 1, n) > 1) for n in nums]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#31",
    "weight": 1.0
  },
  {
    "name": "OddDegreePolynomialRoot:0",
    "sat": "def sat(root: float, coeffs=[1, 2, 3, 17]):\n    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4",
    "ans_type": "float",
    "sol_header": "def sol(coeffs=[1, 2, 3, 17]):",
    "sol_docstring": "    \"\"\"\n    Find a real root of an odd degree polynomial from its coefficients\n\n    Sample Input:\n    [1, 0, 8]\n\n    Sample Output:\n    -2.0  # 1*(-2.0)^3 + 8 == 0\n    \"\"\"",
    "sol_bodies": [
      "    def p(x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(coeffs))\n\n    for attempt in range(100):\n        a, b = -(10 ** attempt), (10 ** attempt)\n        p_a, p_b = p(a), p(b)\n        while p_a * p_b <= 0:\n            mid = (a + b) / 2\n            p_mid = p(mid)\n            if abs(p_mid) < 1e-4:\n                return mid\n            assert mid not in [a, b]\n            if p_mid * p_a > 0:\n                a, p_a = mid, p_mid\n            else:\n                b, p_b = mid, p_mid\n\n    assert False, \"Root finder failed on 100 attempts\""
    ],
    "module": "human_eval.py",
    "notes": "Polynomials of odd degree always have a real solution.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#32",
    "weight": 1.0
  },
  {
    "name": "TwoThirdsSorted:0",
    "sat": "def sat(li: List[int], orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):\n    assert orig[::3] == li[::3], \"Keep every third entry fixed\"\n    assert sorted(li) == sorted(orig), \"Not even a permutation\"\n    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))\n    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):",
    "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every third element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [8, 0, 2, 2, 4, 8, 1, 8, 9, 3]\n    \"\"\"",
    "sol_bodies": [
      "    n = len(orig)\n    your_list = orig[::3]\n    sub = orig[:]\n    for i in range(int((len(sub) + 2) / 3)):\n        sub.pop((2 * i))\n    sub = sorted(sub)\n    answ = []\n    for i in range(int(n / 3)):\n        answ.append(your_list[i])\n        answ.append(sub[i * 2])\n        answ.append(sub[i * 2 + 1])\n    if n % 3 == 1:\n        answ.append(your_list[-1])\n    if n % 3 == 2:\n        answ.append(your_list[-1])\n        answ.append(sub[-1])\n    return answ"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#33",
    "weight": 1.0
  },
  {
    "name": "UniqueSorted:0",
    "sat": "def sat(li: List[int], orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):\n    for i in range(len(li) - 1):\n        assert li[i] < li[i + 1]\n        assert li[i] in orig\n    for n in orig:\n        assert n in li\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):",
    "sol_docstring": "    \"\"\"\n    Find an increasing sequence consisting of the elements of the original list.\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 4, -2, 8, 3]\n\n    Sample Output:\n    [-2, 0, 2, 3, 4, 7, 8, 9]\n    \"\"\"",
    "sol_bodies": [
      "    my_list = sorted(set(orig))\n    return my_list"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#34",
    "weight": 1.0
  },
  {
    "name": "MaxInt:0",
    "sat": "def sat(m: int, hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):\n    return m in hello and not any(m < i for i in hello)",
    "ans_type": "int",
    "sol_header": "def sol(hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):",
    "sol_docstring": "    \"\"\"\n    Find the largest integer in a sequence\n\n    Sample Input:\n    [8, 0, 1, 4, 9, 3, 4, -2, 8, 3]\n\n    Sample Output:\n    9\n    \"\"\"",
    "sol_bodies": [
      "    return max(hello)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#35",
    "weight": 1.0
  },
  {
    "name": "SevenElevenThirteen:0",
    "sat": "def sat(li: List[List[int]], n=19723, lower=1000):\n    assert len({(i, j) for i, j in li}) >= lower, \"not enough 7's (ignoring duplicates)\"\n    return all(str(i)[j] == '7' and (i % 11 == 0 or i % 13 == 0) and 0 <= i < n and 0 <= j for i, j in li)",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(n=19723, lower=1000):",
    "sol_docstring": "    \"\"\"\n    Find all 7's in integers less than n that are divisible by 11 or 13\n\n    Sample Input:\n    79, 3\n\n    Sample Output:\n    [[77, 0], [77, 1], [78, 0]]\n    \"\"\"",
    "sol_bodies": [
      "    return [[i, j] for i in range(n) if (i % 11 == 0 or i % 13 == 0) for j, c in enumerate(str(i)) if c == '7']"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#36",
    "weight": 1.0
  },
  {
    "name": "HalfSorted:0",
    "sat": "def sat(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):\n    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])",
    "ans_type": "List[int]",
    "sol_header": "def sol(orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):",
    "sol_docstring": "    \"\"\"\n    Start with a list of integers, keep every other element in place and otherwise sort the list\n\n    Sample Input:\n    [8, 0, 7, 2, 9, 4, 1, 2, 8, 3]\n\n    Sample Output:\n    [1, 0, 2, 2, 4, 8, 8, 8, 9, 3]\n    \"\"\"",
    "sol_bodies": [
      "    n = len(orig)\n    odds = orig[1::2]\n    evens = sorted(orig[::2])\n    ans = []\n    for i in range(len(evens)):\n        ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#37",
    "weight": 1.0
  },
  {
    "name": "ThreeCycle:0",
    "sat": "def sat(s: str, target=\"Hello world\"):\n\n    def cycle3(trip):\n        return trip if len(trip) != 3 else trip[2] + trip[:2]\n\n    return target == \"\".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))",
    "ans_type": "str",
    "sol_header": "def sol(target=\"Hello world\"):",
    "sol_docstring": "    \"\"\"\n    Given a target string, find a string s such that when each group of three consecutive characters is cycled\n    forward one character, you achieve the target string.\n\n    Sample Input:\n    \"This is a test\"\n\n    Sample Output:\n    'hiT is aste st'\n    \"\"\"",
    "sol_bodies": [
      "    def un_cycle3(trip):\n        return trip if len(trip) != 3 else trip[1:3] + trip[0]\n\n    return \"\".join(un_cycle3(target[i: i + 3]) for i in range(0, len(target), 3))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#38",
    "weight": 1.0
  },
  {
    "name": "PrimeFib:0",
    "sat": "def sat(n: int, lower=123456):\n    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), \"n must be a Fibonacci number\"\n    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), \"n must be prime\"\n    return n > lower",
    "ans_type": "int",
    "sol_header": "def sol(lower=123456):",
    "sol_docstring": "    \"\"\"\n    Find a prime Fibonacci number bigger than a certain threshold, using Ira Gessel's test for Fibonacci numbers.\n\n    Sample Input:\n    10\n\n    Sample Output:\n    11\n    \"\"\"",
    "sol_bodies": [
      "    m, n = 2, 3\n    while True:\n        m, n = n, (m + n)\n        if n > lower and all(n % i for i in range(2, int(n ** 0.5) + 1)):\n            return n"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#39\n\nIra Gessel observed that n is a Fibonacci number if and if either 5 n^2 - 4 or 5 n^2 + 4 is a perfect square",
    "weight": 1.0
  },
  {
    "name": "TripleZeroSum:0",
    "sat": "def sat(inds: List[int], nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):\n    return len(inds) == 3 and sum(nums[i] for i in inds) == 0",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):",
    "sol_docstring": "    \"\"\"\n    Find the indices of three numbers that sum to 0 in a list.\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"",
    "sol_bodies": [
      "    # \\tilde{O}(n^2) algorithm\n    inv = {n: i for i, n in enumerate(nums)}  # note that later duplicates will override earlier entries\n    for i, n in enumerate(nums):\n        if inv[n] == i:\n            del inv[n]\n        if any((-m - n) in inv for m in nums[:i]):  # found solution!\n            j, m = next((j, m) for j, m in enumerate(nums) if (-m - n) in inv)\n            k = inv[-m - n]\n            return sorted([i, j, k])"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#40\n    \nSimilar to but harder than PairZeroSum \\#43.\n    \nThis is a version of the classic [3SUM](https://en.wikipedia.org/wiki/3SUM) problem.",
    "weight": 1.0
  },
  {
    "name": "NumPasses:0",
    "sat": "def sat(count: int, n=981):\n    for i in range(n):\n        for j in range(n):\n            count -= 1\n    return count == 0",
    "ans_type": "int",
    "sol_header": "def sol(n=981):",
    "sol_docstring": "    \"\"\"\n    Given n cars traveling East and n cars traveling West on a road, how many passings will there be?\n    A passing is when one car passes another. The East-bound cars all begin further West than the West-bound cars.\n\n    --Sample input--\n    2\n\n    --Sample output--\n    4\n    \"\"\"",
    "sol_bodies": [
      "    return n ** 2"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#41",
    "weight": 1.0
  },
  {
    "name": "ListInc:0",
    "sat": "def sat(new_list: List[int], old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):\n    return [i - 1 for i in new_list] == old_list",
    "ans_type": "List[int]",
    "sol_header": "def sol(old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):",
    "sol_docstring": "    \"\"\"\n    Decrement each element of new_list by 1 and check that it's old_list\n\n    Sample Input:\n    [17, 15, 99]\n\n    Sample Output:\n    [18, 16, 100]\n    \"\"\"",
    "sol_bodies": [
      "    return [i + 1 for i in old_list]"
    ],
    "module": "human_eval.py",
    "notes": "Increment each element of a list by 1\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#42",
    "weight": 1.0
  },
  {
    "name": "PairZeroSum:0",
    "sat": "def sat(inds: List[int], nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):\n    a, b = inds\n    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):",
    "sol_docstring": "    \"\"\"\n    Find the indices of two numbers that sum to 0 in a list.\n\n    Sample Input:\n    [1, -4, -4, 7, -3]\n\n    Sample Output:\n    [1, 2]\n    \"\"\"",
    "sol_bodies": [
      "    s = set(nums)\n    for i in s:\n        if -i in s:\n            return [nums.index(i), nums.index(-i)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#43\n\nSimilar to TripleZeroSum \\#40",
    "weight": 1.0
  },
  {
    "name": "ChangeBase:0",
    "sat": "def sat(s: str, n=142, base=7):\n    return int(s, base) == n",
    "ans_type": "str",
    "sol_header": "def sol(n=142, base=7):",
    "sol_docstring": "    \"\"\"\n    Write n in the given base as a string\n\n    Sample Input:\n    n=23, base=12\n\n    Sample Output:\n    '1A'\n    \"\"\"",
    "sol_bodies": [
      "    assert 2 <= base <= 10\n    ans = \"\"\n    while n:\n        ans = str(n % base) + ans\n        n //= base\n    return ans or \"0\""
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#44",
    "weight": 1.0
  },
  {
    "name": "TriangleArea:0",
    "sat": "def sat(height: int, area=1319098728582, base=45126):\n    return base * height == 2 * area",
    "ans_type": "int",
    "sol_header": "def sol(area=1319098728582, base=45126):",
    "sol_docstring": "    \"\"\"\n    Find the height of a triangle given the area and base. It is guaranteed that the answer is an integer.\n\n    Sample Input:\n    area = 6, base = 3\n\n    Sample Output:\n    4\n    \"\"\"",
    "sol_bodies": [
      "    return (2 * area) // base"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#45",
    "weight": 1.0
  },
  {
    "name": "Fib4:0",
    "sat": "def sat(init: List[int], target=2021):\n    a, b, c, d = init\n    for i in range(99):\n        a, b, c, d = b, c, d, (a + b + c + d)\n    return a == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=2021):",
    "sol_docstring": "    \"\"\"\n    Define a four-wise Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    four. Given a target number, find an initial four numbers such that the 100th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0, 0]\n    \"\"\"",
    "sol_bodies": [
      "    nums = [target, 0, 0, 0]\n    for i in range(99):\n        x = nums[3] - sum(nums[:3])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:3]\n    return nums"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#46\n\nAlmost identical to problem 63",
    "weight": 1.0
  },
  {
    "name": "Median:0",
    "sat": "def sat(x: int, nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):\n    dev = sum(n - x for n in nums)\n    return dev <= upper",
    "ans_type": "int",
    "sol_header": "def sol(nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):",
    "sol_docstring": "    \"\"\"\n    Find an integer that minimizes the sum of absolute deviations with respect to the given numbers.\n\n    Sample Input:\n    [3, 6, 1, 2, 5, 4, 100], upper=105\n\n    Sample Output:\n    4\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(nums)[len(nums) // 2] if nums else 0"
    ],
    "module": "human_eval.py",
    "notes": "One definition of the median is a number that minimizes the sum of absolute deviations. When there are an\neven number of items, there is an interval of valid solutions.\n\nInspired by [HumanEval](https://github.com/openai/human-eval) \\#47",
    "weight": 1.0
  },
  {
    "name": "Palindrome:0",
    "sat": "def sat(pals: List[bool], strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):\n    return all(pals[i] == (s == s[::-1]) for i, s in enumerate(strs))",
    "ans_type": "List[bool]",
    "sol_header": "def sol(strs=['palindrome', 'madamimadam', '', 'foo', 'eyes', '(-:-)']):",
    "sol_docstring": "    \"\"\"\n    Test whether the given strings are palindromes\n\n    Sample Input:\n    [\"aba\", \"no\"]\n\n    Sample Output:\n    [True, False]\n    \"\"\"",
    "sol_bodies": [
      "    return [s == s[::-1] for s in strs]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#48",
    "weight": 1.0
  },
  {
    "name": "LittleFermat:0",
    "sat": "def sat(exp_poly: List[int], d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):\n    p = len(poly)\n    assert p > 2 and all(p % i for i in range(2, p)), \"Hint: p is a prime > 2\"\n\n    def val(coeffs, n):  # evaluate polynomial mod p\n        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p\n\n    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))",
    "ans_type": "List[int]",
    "sol_header": "def sol(d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):",
    "sol_docstring": "    \"\"\"\n    Fermat's little theorem implies that any polynomial can be written equivalently as a degree p-1\n    polynomial (mod p).\n    Given the p coefficients of a polynomial poly, compute a polynomial equivalent to poly^d (mod p).\n\n    Sample Input:\n    d=2, poly=[1, 0, 0, 1, 0]  # 1 + x^3\n\n    Sample Output:\n    [1, 0, 1, 2, 0]  # 1+ x^2 + 2x^3 because (1 + x^3)^2 = 1 + 2x^3 + x^6 and x^6 = x^2 (mod 5)\n    \"\"\"",
    "sol_bodies": [
      "    \"\"\"\n    Use repeated squaring to exponentiate polynomial\n    \"\"\"\n    p = len(poly)\n\n    def prod(poly1, poly2):  # multiply two polynomials mod p\n        ans = [0] * p\n        for i, a in enumerate(poly1):\n            for j, b in enumerate(poly2):\n                e = (i + j) % (p - 1)\n                if e == 0 and i + j > 1:\n                    e = p - 1\n                ans[e] = (ans[e] + a * b) % p\n        return ans\n\n    ans = [1] + [0] * (p - 1)\n    while d:\n        if d % 2:\n            ans = prod(ans, poly)\n        poly = prod(poly, poly)\n        d //= 2\n    # for i in range(d):\n    #     ans = prod(ans, poly)\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Harder but loosely inspired by [HumanEval](https://github.com/openai/human-eval) \\#49",
    "weight": 1.0
  },
  {
    "name": "ShiftChars:0",
    "sat": "def sat(orig: str, result=\"Hello, world!\", shift=7):\n    n = len(result)\n    assert len(orig) == n\n    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))",
    "ans_type": "str",
    "sol_header": "def sol(result=\"Hello, world!\", shift=7):",
    "sol_docstring": "    \"\"\"\n    Find a string which, when each character is shifted (ascii incremented) by shift, gives the result.\n\n    Sample Input:\n    result='very good', shift=-1\n\n    Sample Output:\n    'wfsz!hppe'\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(chr(ord(c) - shift) for c in result)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#50",
    "weight": 1.0
  },
  {
    "name": "RemoveVowels:0",
    "sat": "def sat(txt: str, text=\"Hello, world!\"):\n    n = 0\n    for c in text:\n        if c.lower() not in \"aeiou\":\n            assert txt[n] == c\n            n += 1\n    assert n == len(txt)\n    return True",
    "ans_type": "str",
    "sol_header": "def sol(text=\"Hello, world!\"):",
    "sol_docstring": "    \"\"\"\n    Remove the vowels from the original string.\n\n    Sample Input:\n    \"very good\"\n\n    Sample Output:\n    'vry gd'\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(c for c in text if c.lower() not in \"aeiou\")"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#51\n\nRelated to FindVowels \\#54",
    "weight": 1.0
  },
  {
    "name": "BelowThreshold:0",
    "sat": "def sat(indexes: List[int], nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):\n    j = 0\n    for i, n in enumerate(nums):\n        if n < thresh:\n            assert indexes[j] == i\n            j += 1\n    assert j == len(indexes)\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):",
    "sol_docstring": "    \"\"\"\n    Find the indexes of numbers below a given threshold\n\n    Sample Input:\n    nums=[4, 7, 11, 5], threshold=10\n\n    Sample Output:\n    [0, 1, 3]\n    \"\"\"",
    "sol_bodies": [
      "    return [i for i, n in enumerate(nums) if n < thresh]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#52",
    "weight": 1.0
  },
  {
    "name": "ListTotal:0",
    "sat": "def sat(n: int, nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):\n    return sum(nums + [-n]) == 0",
    "ans_type": "int",
    "sol_header": "def sol(nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):",
    "sol_docstring": "    \"\"\"\n    Find the number which when appended to the list makes the total 0\n\n    Sample Input:\n    [1, 2, 3]\n\n    Sample Output:\n    -6\n    \"\"\"",
    "sol_bodies": [
      "    return sum(nums)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#53",
    "weight": 1.0
  },
  {
    "name": "DiffChars:0",
    "sat": "def sat(c: str, a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):\n    return (c in a) != (c in b)",
    "ans_type": "str",
    "sol_header": "def sol(a=\"the quick brown fox jumped over the lazy dog\", b=\"how vexingly quick daft zebras jump\"):",
    "sol_docstring": "    \"\"\"\n    Find a character in one string that is not in the other.\n\n    Sample Input:\n    'Do you like green eggs and ham?', 'I do not like green eggs and ham.'\n\n    Sample Output:\n    't'  # or .?yI\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(set(a).symmetric_difference(b))[0]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#54",
    "weight": 1.0
  },
  {
    "name": "Fibonacci:0",
    "sat": "def sat(nums: List[int], n=1402):\n    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=1402):",
    "sol_docstring": "    \"\"\"\n    Find the first n Fibonacci numbers\n\n    Sample Input:\n    4\n\n    Sample Output:\n    [1, 1, 2, 3]\n    \"\"\"",
    "sol_bodies": [
      "    ans = [1, 1]\n    while len(ans) < n:\n        ans.append(ans[-1] + ans[-2])\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#55",
    "weight": 1.0
  },
  {
    "name": "MatchBrackets:0",
    "sat": "def sat(matches: List[int], brackets=\"<<>><<<><>><<>>>\"):\n    for i in range(len(brackets)):\n        j = matches[i]\n        c = brackets[i]\n        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(brackets)",
    "ans_type": "List[int]",
    "sol_header": "def sol(brackets=\"<<>><<<><>><<>>>\"):",
    "sol_docstring": "    \"\"\"\n    Find the index of the matching brackets for each character in the string\n\n    Sample Input:\n    \"<><>\"\n\n    Sample Output:\n    [1, 0, 3, 2]\n    \"\"\"",
    "sol_bodies": [
      "    matches = [-1] * len(brackets)\n    opens = []\n    for i, c in enumerate(brackets):\n        if c == \"<\":\n            opens.append(i)\n        else:\n            assert c == \">\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#56",
    "weight": 1.0
  },
  {
    "name": "Monotonic:0",
    "sat": "def sat(direction: str, nums=[2, 4, 17, 29, 31, 1000, 416629]):\n    if direction == \"increasing\":\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    if direction == \"decreasing\":\n        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))",
    "ans_type": "str",
    "sol_header": "def sol(nums=[2, 4, 17, 29, 31, 1000, 416629]):",
    "sol_docstring": "    \"\"\"\n    Determine the direction ('increasing' or 'decreasing') of monotonic sequence nums\n\n    Sample Input:\n    [1, 2, 5]\n\n    Sample Output:\n    \"increasing\"\n    \"\"\"",
    "sol_bodies": [
      "    return \"increasing\" if len(nums) > 1 and nums[1] > nums[0] else \"decreasing\""
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#57",
    "weight": 1.0
  },
  {
    "name": "CommonNumbers:0",
    "sat": "def sat(common: List[int], a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):\n    return all((i in common) == (i in a and i in b) for i in a + b + common)",
    "ans_type": "List[int]",
    "sol_header": "def sol(a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):",
    "sol_docstring": "    \"\"\"\n    Find numbers common to a and b\n\n    Sample Input:\n    [1, 2, 3], [3, 4, 5]\n\n    Sample Output:\n    [3]\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(set(a).intersection(set(b)))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#58",
    "weight": 1.0
  },
  {
    "name": "LargestPrimeFactor:0",
    "sat": "def sat(p: int, n=101076):\n\n    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))",
    "ans_type": "int",
    "sol_header": "def sol(n=101076):",
    "sol_docstring": "    \"\"\"\n    Find the largest prime factor of n.\n\n    Sample Input:\n    125\n\n    Sample Output:\n    5\n    \"\"\"",
    "sol_bodies": [
      "    def is_prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return next(n // i for i in range(1, n) if n % i == 0 and is_prime(n // i))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#59",
    "weight": 1.0
  },
  {
    "name": "CumulativeSums:0",
    "sat": "def sat(sums: List[int], n=104):\n    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=104):",
    "sol_docstring": "    \"\"\"\n    Find the sums of the integers from 1 to n\n\n    Sample Input:\n    3\n\n    Sample Output:\n    [0, 1, 3, 6]\n    \"\"\"",
    "sol_bodies": [
      "    ans = [0]\n    for i in range(n):\n        ans.append(ans[-1] + i)\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#60",
    "weight": 1.0
  },
  {
    "name": "ParenDepth:0",
    "sat": "def sat(matches: List[int], parens=\"((())()(()()))(())\"):\n    for i, (j, c) in enumerate(zip(matches, parens)):\n        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))\n    return len(matches) == len(parens)",
    "ans_type": "List[int]",
    "sol_header": "def sol(parens=\"((())()(()()))(())\"):",
    "sol_docstring": "    \"\"\"\n    Find the index of the matching parentheses for each character in the string\n\n    Sample Input:\n    \"()((()))\"\n\n    Sample Output:\n    [1, 0, 7, 6, 5, 4, 3, 2]\n    \"\"\"",
    "sol_bodies": [
      "    matches = [-1] * len(parens)\n    opens = []\n    for i, c in enumerate(parens):\n        if c == \"(\":\n            opens.append(i)\n        else:\n            assert c == \")\"\n            j = opens.pop()\n            matches[i] = j\n            matches[j] = i\n    return matches"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#61\n\nNote that problems 61 and 56 are essentially the same",
    "weight": 1.0
  },
  {
    "name": "Derivative:0",
    "sat": "def sat(derivative: List[int], poly=[2, 1, 0, 4, 19, 231, 0, 5]):\n\n    def val(poly, x):\n        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))\n\n    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))",
    "ans_type": "List[int]",
    "sol_header": "def sol(poly=[2, 1, 0, 4, 19, 231, 0, 5]):",
    "sol_docstring": "    \"\"\"\n    Find the derivative of the given polynomial, with coefficients in order of increasing degree\n\n    Sample Input:\n    [3, 4, 1] # 3 + 4x + x^2\n\n    Sample Output:\n    [2, 4]   # 4 + 2x^2\n    \"\"\"",
    "sol_bodies": [
      "    return [i * poly[i] for i in range(1, len(poly))]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#62\n\nThis puzzle gives the raw definition of a derivative in terms of small changes in x.",
    "weight": 1.0
  },
  {
    "name": "Fib3:0",
    "sat": "def sat(init: List[int], target=124156):\n    a, b, c = init\n    for i in range(16):\n        a, b, c = b, c, (a + b + c)\n    return a == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=124156):",
    "sol_docstring": "    \"\"\"\n    Define a triple-Fibonacci sequence to be a sequence such that each number is the sum of the previous\n    three. Given a target number, find an initial triple such that the 17th number in the sequence is the\n    given target number.\n\n    Sample Input:\n    0\n\n    Sample Output:\n    [0, 0, 0]\n    \"\"\"",
    "sol_bodies": [
      "    nums = [target, 0, 0]\n    for i in range(16):\n        x = nums[-1] - sum(nums[:-1])  # x is such that x + nums[:3] == nums[3]\n        nums = [x] + nums[:-1]\n    return nums"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#63\n\nAlmost identical to problem 46",
    "weight": 1.0
  },
  {
    "name": "FindVowels:0",
    "sat": "def sat(vowels: List[str], texts=['Hello, world!', 'Goodbye, world!']):\n    for v, t in zip(vowels, texts):\n        i = 0\n        for j, c in enumerate(t):\n            if c.lower() in \"aeiou\" or c.lower() == 'y' and j == len(t) - 1:\n                assert v[i] == c\n                i += 1\n        assert i == len(v)\n    return len(vowels) == len(texts)",
    "ans_type": "List[str]",
    "sol_header": "def sol(texts=['Hello, world!', 'Goodbye, world!']):",
    "sol_docstring": "    \"\"\"\n    Find the vowels from each of the original texts (y counts as a vowel at the end of the word)\n\n    Sample Input:\n    [\"You can do it!\", \"CAT\"]\n\n    Sample Output:\n    [\"ouaoi\", \"A\"]\n    \"\"\"",
    "sol_bodies": [
      "    return [\"\".join(c for c in text if c.lower() in \"aeiou\") + (text[-1] if text[-1].lower() == \"y\" else \"\")\n            for text in texts]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#64\n\nVery similar to RemoveVowels \\#51",
    "weight": 1.0
  },
  {
    "name": "CircularShiftNum:0",
    "sat": "def sat(shifted: str, n=124582369835, shift=3):\n    if shift > len(str(n)):\n        return n == int(shifted[::-1])\n    return n == int(shifted[-shift:] + shifted[:-shift])",
    "ans_type": "str",
    "sol_header": "def sol(n=124582369835, shift=3):",
    "sol_docstring": "    \"\"\"\n    Shift the decimal digits n places to the left, wrapping the extra digits around. If shift > the number of\n    digits of n, reverse the string.\n\n    n=12345 shift=2 => '34512'\n    \"\"\"",
    "sol_bodies": [
      "    s = str(n)\n    if shift > len(s):\n        return s[::-1]\n    return s[shift:] + s[:shift]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#65",
    "weight": 1.0
  },
  {
    "name": "CharSum:0",
    "sat": "def sat(tot: int, s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):\n    for c in s:\n        if c.isupper():\n            tot -= ord(c)\n    return tot == 0",
    "ans_type": "int",
    "sol_header": "def sol(s=\"Add ME uP AND YOU WILL GET A BIG NUMBER!\"):",
    "sol_docstring": "    \"\"\"\n    Compute the sum of the ASCII values of the upper-case characters in the string.\n\n    Sample Input:\n    ARt\n\n    Sample Output:\n    147 # = 65 + 82\n    \"\"\"",
    "sol_bodies": [
      "    return sum(ord(c) for c in s if c.isupper())"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#66",
    "weight": 1.0
  },
  {
    "name": "MissingBananas:0",
    "sat": "def sat(bananas: int, bowl=\"5024 apples and 12189 oranges\", total=12491241):\n    bowl += f\" and {bananas} bananas\"\n    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total",
    "ans_type": "int",
    "sol_header": "def sol(bowl=\"5024 apples and 12189 oranges\", total=12491241):",
    "sol_docstring": "    \"\"\"\n    Determine how many bananas are necessary to reach a certain total amount of fruit\n\n    bowl=\"3 apples and 4 oranges\", total=12 => 5\n    \"\"\"",
    "sol_bodies": [
      "    apples, oranges = [int(s) for s in bowl.split() if s.isdigit()]\n    return total - apples - oranges"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#67",
    "weight": 1.0
  },
  {
    "name": "SmallestEven:0",
    "sat": "def sat(val_index: List[int], nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):\n    if val_index == []:\n        return all(n % 2 == 1 for n in nums)\n    v, i = val_index\n    assert v % 2 == 0 and nums[i] == v\n    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):",
    "sol_docstring": "    \"\"\"\n    Given an array of nums representing a branch on a binary tree, find the minimum even value and its index.\n    In the case of a tie, return the smallest index. If there are no even numbers, the answer is [].\n\n    Sample Input:\n    [1, 7, 4, 6, 10, 11, 14]\n\n    Sample Output:\n    [4, 2]\n    \"\"\"",
    "sol_bodies": [
      "    if any(n % 2 == 0 for n in nums):\n        return min([v, i] for i, v in enumerate(nums) if v % 2 == 0)\n    else:\n        return []"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#68",
    "weight": 1.0
  },
  {
    "name": "GreatestHIndex:0",
    "sat": "def sat(h: int, seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):\n    for i in seq:\n        assert not (i > 0 and i > h and seq.count(i) >= i)\n    return h == -1 or seq.count(h) >= h > 0",
    "ans_type": "int",
    "sol_header": "def sol(seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):",
    "sol_docstring": "    \"\"\"\n    Find the h-index, the largest positive number h such that that h occurs in the sequence at least h times.\n    h = -1 if there is no such positive number.\n\n    Sample Input:\n    [1, 2, 2, 3, 3, 3, 4, 4]\n\n    Sample Output:\n    3\n    \"\"\"",
    "sol_bodies": [
      "    return max([-1] + [i for i in seq if i > 0 and seq.count(i) >= i])"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#69",
    "weight": 1.0
  },
  {
    "name": "WildSort:0",
    "sat": "def sat(strange: List[int], li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):\n    assert sorted(strange) == sorted(li), \"Must be a permutation\"\n    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))",
    "ans_type": "List[int]",
    "sol_header": "def sol(li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):",
    "sol_docstring": "    \"\"\"\n    Find the following strange sort of li: the first element is the smallest, the second is the largest of the\n    remaining, the third is the smallest of the remaining, the fourth is the smallest of the remaining, etc.\n\n    Sample Input:\n    [1, 2, 7, 3, 4, 5, 6]\n\n    Sample Output:\n    [1, 7, 2, 6, 3, 5, 4]\n    \"\"\"",
    "sol_bodies": [
      "    s = sorted(li)\n    i = 0\n    j = len(li) - 1\n    ans = []\n    while i <= j:\n        if len(ans) % 2:\n            ans.append(s[j])\n            j -= 1\n        else:\n            ans.append(s[i])\n            i += 1\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#70",
    "weight": 1.0
  },
  {
    "name": "HeronTriangle:0",
    "sat": "def sat(coords: List[List[float]], sides=[8.9, 10.8, 17.0]):\n    assert len(coords) == 3\n    sides2 = [((x - x2) ** 2 + (y - y2) ** 2) ** 0.5 for i, (x, y) in enumerate(coords) for x2, y2 in coords[:i]]\n    return all(abs(a - b) < 1e-6 for a, b in zip(sorted(sides), sorted(sides2)))",
    "ans_type": "List[List[float]]",
    "sol_header": "def sol(sides=[8.9, 10.8, 17.0]):",
    "sol_docstring": "    \"\"\"\n    Find the coordinates of a triangle with the given side lengths\n\n    Sample Input:\n    [3.0, 4.0, 5.0\n\n    Sample Output:\n    [[0.0, 0.0], [3.0, 0.0], [0.0, 4.0]]\n    \"\"\"",
    "sol_bodies": [
      "    a, b, c = sorted(sides)\n\n    s = sum(sides) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5  # Heron's formula\n\n    y = 2 * area / a  # height\n    x = (c ** 2 - y ** 2) ** 0.5\n    return [[0.0, 0.0], [a, 0.0], [x, y]]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#71\n\nThat problem essentially asks for Heron's formula for the area of a triangle in terms of its three sides.\nIn our version, we consider the related problem (also solved by Heron's formula) of finding 2d coordinates\nof a triangle with the given sides. If one knows the area, this is a straightforward calculation.",
    "weight": 1.0
  },
  {
    "name": "InvestigateCrash:0",
    "sat": "def sat(problem: int, weights=[1, 2, 5, 2, 1, 17], max_weight=100):\n    if problem == -1:\n        return sum(weights) > max_weight\n    return weights[problem] != weights[- 1 - problem]",
    "ans_type": "int",
    "sol_header": "def sol(weights=[1, 2, 5, 2, 1, 17], max_weight=100):",
    "sol_docstring": "    \"\"\"\n    An object will \"fly\" if its weights are a palindrome and sum to <= max_weight. The given object won't fly.\n    You have to determine why. Find index where the weights aren't a palindrome or -1 if weights are too big.\n\n    weights=[77, 40], max_weight=100 => -1\n\n    weights=[1,2,3], max_weight=50   => 0 # because 1 != 3\n    \"\"\"",
    "sol_bodies": [
      "    if sum(weights) > max_weight:\n        return -1\n    return next(i for i, w in enumerate(weights) if weights[-i - 1] != weights[i])"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#72",
    "weight": 1.0
  },
  {
    "name": "ClosestPalindrome:0",
    "sat": "def sat(pal: str, s=\"palindromordinals\"):\n    assert pal == pal[::-1] and len(pal) == len(s)\n    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2",
    "ans_type": "str",
    "sol_header": "def sol(s=\"palindromordinals\"):",
    "sol_docstring": "    \"\"\"\n    Find the closest palindrome\n\n    Sample Input:\n    \"cat\"\n\n    Sample Output:\n    \"tat\"\n    \"\"\"",
    "sol_bodies": [
      "    n = len(s)\n    return s[:(n + 1) // 2] + s[:n // 2][::-1]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#73",
    "weight": 1.0
  },
  {
    "name": "NarrowerList:0",
    "sat": "def sat(li: List[str], lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):\n    width = sum(len(s) for s in li)\n    for li2 in lists:\n        assert width <= sum(len(s) for s in li2)\n    return li in lists",
    "ans_type": "List[str]",
    "sol_header": "def sol(lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):",
    "sol_docstring": "    \"\"\"\n    Find the list that has fewer total characters (including repetitions)\n\n    Sample Input:\n    [[\"sh\", \"ort\"], [\"longest\"]]\n\n    Sample Output:\n    [[\"sh\", \"ort\"]\n    \"\"\"",
    "sol_bodies": [
      "    return min(lists, key=lambda x: sum(len(i) for i in x))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#74",
    "weight": 1.0
  },
  {
    "name": "ThreePrimes:0",
    "sat": "def sat(factors: List[List[int]]):\n    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    assert all(p in primes for f in factors for p in f), \"all factors must be prime\"\n    nums = {p * q * r for p, q, r in factors}\n    return max(nums) < 1000 and len(nums) == 247",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find all 247 integers <= 1000 that are the product of exactly three primes.\n    Each integer should represented as the list of its three prime factors.\n    [[2, 2, 2], [2, 2, 3],  [2, 2, 5], ...\n    \"\"\"",
    "sol_bodies": [
      "    primes = set(range(2, 1000))\n    for n in range(2, 1000):\n        if n in primes:\n            primes.difference_update(range(2 * n, 1000, n))\n    return [[p, q, r] for p in primes for q in primes if p <= q for r in primes if q <= r and p * q * r < 1000]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#75",
    "weight": 1.0
  },
  {
    "name": "IntegerLog:0",
    "sat": "def sat(x: int, a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):\n    return a ** x == n",
    "ans_type": "int",
    "sol_header": "def sol(a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):",
    "sol_docstring": "    \"\"\"Find an integer exponent x such that a^x = n\n    Sample Input:\n    a=2, n=1024\n\n    Sample Output:\n    x = 10\n    \"\"\"",
    "sol_bodies": [
      "    m = 1\n    x = 0\n    while m != n:\n        x += 1\n        m *= a\n    return x"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#76",
    "weight": 1.0
  },
  {
    "name": "CubeRoot:0",
    "sat": "def sat(x: int, n=42714774173606970182754018064350848294149432972747296768):\n    return x ** 3 == n",
    "ans_type": "int",
    "sol_header": "def sol(n=42714774173606970182754018064350848294149432972747296768):",
    "sol_docstring": "    \"\"\"Find an integer that when cubed is n\n\n    Sample Input:\n    21\n\n    Sample Output:\n    3\n    \"\"\"",
    "sol_bodies": [
      "    # Using Newton's method\n    m = abs(n)\n    x = round(abs(n) ** (1 / 3))\n    while x ** 3 != m:\n        x += (m - x ** 3) // (3 * x ** 2)\n    return -x if n < 0 else x"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#77\n\nWe made it harder by giving very large n for which `round(n ** (1/3))`",
    "weight": 1.0
  },
  {
    "name": "HexPrimes:0",
    "sat": "def sat(primes: List[bool], n=\"A4D4455214122CE192CCBE3\"):\n    return all(primes[i] == (c in \"2357BD\") for i, c in enumerate(n))",
    "ans_type": "List[bool]",
    "sol_header": "def sol(n=\"A4D4455214122CE192CCBE3\"):",
    "sol_docstring": "    \"\"\"Determine which characters of a hexidecimal correspond to prime numbers\n\n    Sample Input:\n    \"123ABCD\"\n\n    Sample Output:\n    [False, True, True, False, True, False True]\n    \"\"\"",
    "sol_bodies": [
      "    return [c in \"2357BD\" for c in n]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#78",
    "weight": 1.0
  },
  {
    "name": "Binarize:0",
    "sat": "def sat(b: str, n=5324680297138495285):\n    assert b[:4] == b[-4:] == 'bits'\n    inside = b[4:-4]\n    assert all(c in \"01\" for c in inside)\n    assert inside[0] == \"1\" or len(inside) == 1\n    m = 0\n    for c in inside:\n        m = 2 * m + int(c)\n    return m == n",
    "ans_type": "str",
    "sol_header": "def sol(n=5324680297138495285):",
    "sol_docstring": "    \"\"\"Write n base 2 followed and preceded by 'bits'\n    Sample Input:\n    2\n\n    Sample Output:\n    bits10bits\n    \"\"\"",
    "sol_bodies": [
      "    s = bin(n)[2:]\n    return f'bits{s}bits'"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#79",
    "weight": 1.0
  },
  {
    "name": "NearbyDuplicates:0",
    "sat": "def sat(indices: List[int], s=\"I am an unhappy string!\"):\n    i, j = indices\n    return s[i] == s[j] and 0 <= i < j < i + 3",
    "ans_type": "List[int]",
    "sol_header": "def sol(s=\"I am an unhappy string!\"):",
    "sol_docstring": "    \"\"\"A string is happy if every three consecutive characters are distinct. Find two indices making s unhappy.\n    Sample Input:\n    \"street\"\n\n    Sample Output:\n    [3, 4]\n    \"\"\"",
    "sol_bodies": [
      "    for i in range(len(s) - 2):\n        if s[i] == s[i + 1]:\n            return [i, i + 1]\n        if s[i] == s[i + 2]:\n            return [i, i + 2]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#80",
    "weight": 1.0
  },
  {
    "name": "Grader:0",
    "sat": "def sat(grades: List[str], gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):\n    assert len(grades) == len(gpas)\n    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    for grade, gpa in zip(grades, gpas):\n        i = letters.index(grade)\n        assert gpa >= scores[i]\n        assert i == 0 or gpa <= scores[i - 1]\n    return True",
    "ans_type": "List[str]",
    "sol_header": "def sol(gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):",
    "sol_docstring": "    \"\"\"\n    Convert GPAs to letter grades according to the following table:\n    4.0: A+\n    3.7: A\n    3.4: A-\n    3.0: B+\n    2.7: B\n    2.4: B-\n    2.0: C+\n    1.7: C\n    1.4: C-\n    below: F\n\n    Sample input: [4.0, 3.5, 3.8]\n    Sample output: ['A+', 'A-', 'A']\n    \"\"\"",
    "sol_bodies": [
      "    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']\n    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]\n    ans = []\n    for gpa in gpas:\n        i = 0\n        while gpa < scores[i]:\n            i += 1\n        ans.append(letters[i])\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#81",
    "weight": 1.0
  },
  {
    "name": "FactorString:0",
    "sat": "def sat(factor: str, s=\"catscatcatscatcatscat\"):\n    return len(factor) < len(s) and s == factor * (len(s) // len(factor))",
    "ans_type": "str",
    "sol_header": "def sol(s=\"catscatcatscatcatscat\"):",
    "sol_docstring": "    \"\"\"Find a string which when repeated more than once gives s\n    Sample Input:\n    \"haha\"\n\n    Sample Output:\n    \"ha\"\n    \"\"\"",
    "sol_bodies": [
      "    n = len(s)\n    return next(s[:i] for i in range(1, len(s)) if s == s[:i] * (n // i))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#82",
    "weight": 1.0
  },
  {
    "name": "OneEnded:0",
    "sat": "def sat(nums: List[int], n=5):\n    count = 18 * (10 ** (n - 2)) if n > 1 else 1\n    strs = {str(n) for n in nums}\n    return len(strs) == count and all(s.startswith(\"1\") or s.endswith(\"1\") and len(s) == n for s in strs)",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=5):",
    "sol_docstring": "    \"\"\"Find all n-digit integers that start or end with 1\n\n    1 => [1]\"\"\"",
    "sol_bodies": [
      "    ans = []\n    for i in range(10 ** (n - 1), 10 ** n):\n        assert len(str(i)) == n\n        if str(i).startswith(\"1\") or str(i).endswith(\"1\"):\n            ans.append(i)\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#83",
    "weight": 1.0
  },
  {
    "name": "BitSum:0",
    "sat": "def sat(n: int, b=107, s=25):\n    n_str = bin(n)[2:]  # n in binary\n    return len(n_str) == b and sum(int(i) for i in n_str) == s",
    "ans_type": "int",
    "sol_header": "def sol(b=107, s=25):",
    "sol_docstring": "    \"\"\"Find an b-bit integer with a bit-sum of s\n\n    b=3, s=2 => 5 # 5 is 101 in binary\n    \"\"\"",
    "sol_bodies": [
      "    return int(\"1\" * s + \"0\" * (b - s), 2)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#84",
    "weight": 1.0
  },
  {
    "name": "EvenOddSum:0",
    "sat": "def sat(even_odd_sum: int, nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):\n    for i in nums[1::2]:\n        if i % 2 == 0:\n            even_odd_sum -= i\n    return even_odd_sum == 0",
    "ans_type": "int",
    "sol_header": "def sol(nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):",
    "sol_docstring": "    \"\"\"Find the sum of the even elements that are at odd indices\n\n    [1, 2, 8, 3, 9, 4] => 6\n    \"\"\"",
    "sol_bodies": [
      "    return sum(i for i in nums[1::2] if i % 2 == 0)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#85\n\nVery similar to OddEvenSum \\#121",
    "weight": 1.0
  },
  {
    "name": "AntiShuffle:0",
    "sat": "def sat(s: str, orig=\"Hello world!!!\"):\n    for a, b in zip(s.split(' '), orig.split(' ')):\n        for i in range(len(a) - 1):\n            assert a[i] <= a[i + 1], \"characters must s-words be in increasing order\"\n        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), \"must have same chars\"\n    return len(s) == len(orig)",
    "ans_type": "str",
    "sol_header": "def sol(orig=\"Hello world!!!\"):",
    "sol_docstring": "    \"\"\"Create a new string by taking s, and word by word rearranging its characters in ascii order\n    Sample input:\n    'maltos wow'\n\n    Sample output:\n    'almost oww'\n    \"\"\"",
    "sol_bodies": [
      "    return \" \".join(\"\".join(sorted(w)) for w in orig.split(' '))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#86",
    "weight": 1.0
  },
  {
    "name": "UnevenFind:0",
    "sat": "def sat(indices: List[List[int]], uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):\n    for i, j in indices:\n        assert uneven[i][j] == target\n    for i, row in enumerate(uneven):\n        for j, n in enumerate(row):\n            assert n != target or [i, j] in indices\n    return True",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(uneven=[[1, 3, 2, 32, 17], [17, 2, 48, 17], [], [9, 35, 4], [3, 17]], target=17):",
    "sol_docstring": "    \"\"\"Find the indices of all occurrences of target in the uneven matrix\n    Sample input:\n    uneven=[[2, 3, 2], [], [9, 2]], target=2\n\n    Sample output:\n    [[0, 0], [0, 2], [2, 1]]\n    \"\"\"",
    "sol_bodies": [
      "    return [[i, j] for i, row in enumerate(uneven) for j, n in enumerate(row) if n == target]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#87",
    "weight": 1.0
  },
  {
    "name": "UpDownSort:0",
    "sat": "def sat(up_down: List[int], nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):\n    assert all(up_down.count(i) == nums.count(i) for i in set(up_down + nums)), \"not a reordering\"\n    increasing_sign = 1 if ((nums[0] + nums[-1]) % 2 == 1) else -1\n    return all((up_down[i + 1] - up_down[i]) * increasing_sign >= 0 for i in range(len(up_down) - 1))",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):",
    "sol_docstring": "    \"\"\"Reorder nums in increasing/decreasing order based on whether the first plus last element is even/odd\n\n    Sample input:\n    [1, 7, 4]\n\n    Sample output:\n    [1, 4, 7] # because 1 + 4 is odd\n\n    Sample input:\n    [1, 7, 5]\n\n    Sample output:\n    [8, 5, 1] # because 1 + 5 is even\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(nums, reverse=(False if (nums[0] + nums[-1]) % 2 else True))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#88",
    "weight": 1.0
  },
  {
    "name": "SubstitutionCypher:0",
    "sat": "def sat(encrypted: str, orig=\"Hello, world!\"):\n    assert len(encrypted) == len(orig)\n    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))",
    "ans_type": "str",
    "sol_header": "def sol(orig=\"Hello, world!\"):",
    "sol_docstring": "    \"\"\"Apply a substitution cypher in which each character is advanced by two multiplied by two places.\n\n    'substitution cypher' => 'wyfwxmxyxmsr$g}tliv'\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(chr(ord(b) + 2 * 2) for b in orig)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#89",
    "weight": 1.0
  },
  {
    "name": "SecondSmallestUnique:0",
    "sat": "def sat(n: int, nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):\n    assert n in nums\n    return len({i for i in nums if i <= n}) == 2",
    "ans_type": "int",
    "sol_header": "def sol(nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):",
    "sol_docstring": "    \"\"\"Find the second smallest unique number in the list nums.\n\n    Sample input:\n    [2, 5, 2, 7, 9]\n\n    Sample output:\n    5\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(set(nums))[1]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#90",
    "weight": 1.0
  },
  {
    "name": "FindBored:0",
    "sat": "def sat(boring: List[str], text=\"This is not boring. I am boring! I am sooo tired.\"):\n    sentences = text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\")\n    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != [\"I\"]]\n    return sorted(boring_and_exciting) == sorted(sentences)",
    "ans_type": "List[str]",
    "sol_header": "def sol(text=\"This is not boring. I am boring! I am sooo tired.\"):",
    "sol_docstring": "    \"\"\"A bored sentence starts with the word \"I\". Find all bored sentences in s. Sentence delimiters are '.!?'\n\n    --- Example input ---\n    'I wrote this. You read it? I think I am so cool. In another time, I would be lame.'\n\n    --- Example output ---\n    ['I wrote this', ' I think I am so cool']\n\n    \"\"\"",
    "sol_bodies": [
      "    return [s for s in text.replace(\"!\", \".\").replace(\"?\", \".\").split(\".\") if s.split()[:1] == [\"I\"]]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#91",
    "weight": 1.0
  },
  {
    "name": "IdentifyZeroTrips:0",
    "sat": "def sat(zero_sums: List[bool], trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):\n    return len(zero_sums) == len(trips) and all(z == ((a + b + c) == 0) for z, (a, b, c) in zip(zero_sums, trips))",
    "ans_type": "List[bool]",
    "sol_header": "def sol(trips=[[1253532, -3920635, 332], [-24, 18, 6], [0, 5, -5], [1, 1, 1], [-20, 17, 4]]):",
    "sol_docstring": "    \"\"\"Determine which triples sum to zero\n\n    --- Example input ---\n    [1, 2, 4, -3, 5]\n\n    --- Example output ---\n    [0, 1, 3]\n    \"\"\"",
    "sol_bodies": [
      "    return [sum(t) == 0 for t in trips]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#92",
    "weight": 1.0
  },
  {
    "name": "WeirdDecodeVowels:0",
    "sat": "def sat(s: str, target=\"Hello, world!\"):\n    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return s.swapcase() == target.translate(subs)",
    "ans_type": "str",
    "sol_header": "def sol(target=\"Hello, world!\"):",
    "sol_docstring": "    \"\"\"Find string s that, when case is flipped gives target where vowels are replaced by chars two later.\n    --- Example input ---\n    'THIS is a TEST'\n\n    --- Example output ---\n    'thks KS C tgst'\n    \"\"\"",
    "sol_bodies": [
      "    subs = {ord(c): ord(c) + 2 for c in \"aeiouAEIOU\"}\n    return target.translate(subs).swapcase()"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#93",
    "weight": 1.0
  },
  {
    "name": "LargestPrimeDigitSum:0",
    "sat": "def sat(ans: List[int], nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):\n    i, digit_sum = ans\n    n = nums[i]\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):",
    "sol_docstring": "    \"\"\"Find the index of the largest prime in the list and the sum of its digits\n\n    --- Example input ---\n    [2, 4, 7, 19, 21]\n\n    --- Example output ---\n    [3, 10]\n    \"\"\"",
    "sol_bodies": [
      "    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    n, i = max((n, i) for i, n in enumerate(nums) if is_prime(n))\n    return [i, sum(int(c) for c in str(n))]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#94",
    "weight": 1.0
  },
  {
    "name": "OddCase:0",
    "sat": "def sat(different: str, d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):\n    return different in d and all(k.islower() != different.islower() for k in d if k != different)",
    "ans_type": "str",
    "sol_header": "def sol(d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):",
    "sol_docstring": "    \"\"\"Find the dictionary key whose case is different than all other keys\n\n    --- Example input ---\n    {\"red\": \"\", \"GREEN\": \"\", \"blue\": \"orange\"}\n\n    --- Example output ---\n    \"GREEN\"\n    \"\"\"",
    "sol_bodies": [
      "    for different in d:\n        if all(k.islower() != different.islower() for k in d if k != different):\n            return different"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#95",
    "weight": 1.0
  },
  {
    "name": "PrimesUpTo:0",
    "sat": "def sat(primes: List[int], n=1234):\n    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)\n    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=1234):",
    "sol_docstring": "    \"\"\"Find all primes up to n\n\n    --- Example input ---\n    9\n\n    --- Example output ---\n    [2, 3, 5, 7]\n    \"\"\"",
    "sol_bodies": [
      "    primes = []\n    candidates = set(range(2, n))\n    for i in range(2, n):\n        if i in candidates:\n            primes.append(i)\n            candidates.difference_update(range(i, n, i))\n    return primes"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#96",
    "weight": 1.0
  },
  {
    "name": "UnitsProduct:0",
    "sat": "def sat(prod: int, nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):\n    if not all(nums):\n        return prod == 0\n    for n in nums:\n        k = abs(n % 10)\n        if k == 0:\n            return prod == 0\n        assert prod % k == 0\n        prod //= k\n    return prod == 1",
    "ans_type": "int",
    "sol_header": "def sol(nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):",
    "sol_docstring": "    \"\"\"Find the product of the units digits in the numbers\n\n    [12, 34] => 8\n    \"\"\"",
    "sol_bodies": [
      "    prod = 1\n    for n in nums:\n        prod *= abs(n % 10)\n    return prod"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#97",
    "weight": 1.0
  },
  {
    "name": "UppercaseEven:0",
    "sat": "def sat(positions: List[int], s=\"ThIs is A tEsT, Or *IS* iT?\"):\n    assert all(s[i] in \"AEIOU\" for i in positions)\n    return all(i in positions or c not in \"AEIOU\" or i % 2 == 1 for i, c in enumerate(s))",
    "ans_type": "List[int]",
    "sol_header": "def sol(s=\"ThIs is A tEsT, Or *IS* iT?\"):",
    "sol_docstring": "    \"\"\"Find the positions of all uppercase vowels (not counting Y) in even indices\n\n    \"EAT here NOW\" => [0, 10]\n    \"\"\"",
    "sol_bodies": [
      "    return [i for i, c in enumerate(s) if i % 2 == 0 and c in \"AEIOU\"]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#98",
    "weight": 1.0
  },
  {
    "name": "ClosestInteger:0",
    "sat": "def sat(n: int, x=329437923.5):\n    return abs(n - x) <= 0.5",
    "ans_type": "int",
    "sol_header": "def sol(x=329437923.5):",
    "sol_docstring": "    \"\"\"Round to nearest integer\n\n    --- input ---\n    3.7\n\n    --- output ---\n    4\n    \"\"\"",
    "sol_bodies": [
      "    return round(x)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#99\n\nSince we can tolerate more than one answer per puzzle, we do not need to specify a tie-breaking rule.",
    "weight": 1.0
  },
  {
    "name": "StonePiles:0",
    "sat": "def sat(li: List[int], n=909):\n    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=909):",
    "sol_docstring": "    \"\"\"We are making n stone piles! The first pile has n stones. If n is even, then all piles have an even\n    number of stones. If n is odd, all piles have an odd number of stones. Each pile must more stones\n    than the previous pile but as few as possible. Return the number of stones in each pile.\n\n    2 => [2, 4]\n    \"\"\"",
    "sol_bodies": [
      "    return [n + 2 * i for i in range(n)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#100",
    "weight": 1.0
  },
  {
    "name": "CompleteSplit:0",
    "sat": "def sat(splits: List[List[str]], string=\"Hello, world!  You look like you're on turtles.\"):\n    words, separators = splits\n    assert len(words) == len(separators) + 1\n    merged = []\n    for w, s in zip(words, separators + [\" \"]):\n        assert s.count(\" \") + s.count(\",\") == len(s) > 0\n        assert w.count(\" \") + w.count(\",\") == 0\n        merged += [w, s]\n    return \"\".join(merged[:-1]) == string",
    "ans_type": "List[List[str]]",
    "sol_header": "def sol(string=\"Hello, world!  You look like you're on turtles.\"):",
    "sol_docstring": "    \"\"\"\n    Split a string of words separated by commas and spaces into 2 lists: words and separators\n\n    Sample input: \"Hi there, Anna\"\n    Sample output: [[\"Hi\", \"there\", \"Anna\"], [\" \", \", \"]]\n    \"\"\"",
    "sol_bodies": [
      "    import re\n    merged = re.split(r\"([ ,]+)\", string)\n    return [merged[::2], merged[1::2]]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#101",
    "weight": 1.0
  },
  {
    "name": "BiggestEven:0",
    "sat": "def sat(x: int, a=145, b=24126846790974):\n    if x == -1:\n        return all(i % 2 == 1 for i in range(a, b + 1))\n    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))",
    "ans_type": "int",
    "sol_header": "def sol(a=145, b=24126846790974):",
    "sol_docstring": "    \"\"\"Return the biggest even number between a and b inclusive, or -1 if there is no such number\n\n    Example input:\n    a=20, b=99\n\n    Example output:\n    98\n    \"\"\"",
    "sol_bodies": [
      "    if a > b or (a == b and a % 2 == 1):\n        return -1\n    return b if b % 2 == 0 else b - 1"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#102",
    "weight": 1.0
  },
  {
    "name": "BinaryAverage:0",
    "sat": "def sat(s: str, a=-103252, b=10657):\n    n = int(s, 2)\n    r = range(a, b)\n    if len(r) == 0:\n        return n == -1\n    mu = sum(r) / len(r)\n    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))",
    "ans_type": "str",
    "sol_header": "def sol(a=-103252, b=10657):",
    "sol_docstring": "    \"\"\"Return the average of the numbers a through b rounded to nearest integer, in binary\n    (or -1 if there are no such numbers)\n\n    a=4, b=7 => '110' because the mean of 4, 5, 6 is 5 which is 110 in binary\n    \"\"\"",
    "sol_bodies": [
      "    r = range(a, b)\n    if len(r) == 0:\n        return \"-1\"\n    return bin(round(sum(r) / len(r)))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#103",
    "weight": 1.0
  },
  {
    "name": "SortedOdds:0",
    "sat": "def sat(sub: List[int], nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):\n    for i in range(len(sub)):\n        n = sub[i]\n        assert n == min(sub[i:])\n        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits\n        assert sub.count(n) == nums.count(n)\n\n    for n in nums:\n        if n not in sub:\n            assert any(int(c) % 2 == 0 for c in str(abs(n)))\n\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):",
    "sol_docstring": "    \"\"\"Find the sublist of numbers with only odd digits in increasing order\n\n    [17, 21, 18, 1, 4] => [1, 17, 21]\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(n for n in nums if all(int(c) % 2 for c in str(abs(n))))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#104",
    "weight": 1.0
  },
  {
    "name": "BackwardsDigits:0",
    "sat": "def sat(backwards_digits: List[str], nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):\n    digits = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    li = [digits[s] for s in backwards_digits]\n    for i, n in enumerate(li):\n        assert n == max(li[i: i + 2])\n        assert nums.count(n) == li.count(n)\n\n    return all(n not in range(1, 10) or n in li for n in nums)",
    "ans_type": "List[str]",
    "sol_header": "def sol(nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):",
    "sol_docstring": "    \"\"\"Return the single digits in nums sorted backwards and converted to English words\n\n    [2, 3, 4, 5, 17] => ['five', 'four', 'three', 'two']\n    \"\"\"",
    "sol_bodies": [
      "    digits = {1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", 6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    return [digits[n] for n in sorted(nums, reverse=True) if n in digits]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#105",
    "weight": 1.0
  },
  {
    "name": "AlternatingFactorials:0",
    "sat": "def sat(li: List[int], n=100):\n    assert len(li) == n\n    for i, m in enumerate(li):\n        if i < 2:\n            assert m == i + 1\n        elif i % 2 == 1:\n            assert m == li[i - 2] + i + (i + 1)\n        else:\n            assert m == li[i - 2] * i * (i + 1)\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=100):",
    "sol_docstring": "    \"\"\"Output a list of n integers, where the mth entry is m! if m is even or else (1+2+...+m)\n\n    5 => [1, 2, 6, 9, 120]\n    \"\"\"",
    "sol_bodies": [
      "    ans = []\n    for i in range(n):\n        if i < 2:\n            m = i + 1\n        elif i % 2 == 1:\n            m = ans[i - 2] + i + (i + 1)\n        else:\n            m = ans[i - 2] * i * (i + 1)\n        ans.append(m)\n\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#106",
    "weight": 1.0
  },
  {
    "name": "EvenPalindromeNumbers:0",
    "sat": "def sat(pals: List[int], n=1099, count=49):\n    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=1099, count=49):",
    "sol_docstring": "    \"\"\"Find all even palindromes up to n\n\n    3 => [0, 2]\n    \"\"\"",
    "sol_bodies": [
      "    return [i for i in range(0, n + 1, 2) if str(i) == str(i)[::-1]]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#107",
    "weight": 1.0
  },
  {
    "name": "PositiveDigitSums:0",
    "sat": "def sat(pos: List[int], nums=[-804, 9124, -945, 2410, 0, 21, -123]):\n    for n in pos + nums:\n        s = str(n)\n        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:\n            assert n not in pos\n        else:\n            assert pos.count(n) == nums.count(n)\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[-804, 9124, -945, 2410, 0, 21, -123]):",
    "sol_docstring": "    \"\"\"Filter for the numbers in nums whose sum of digits is > 0, where the first digit can be negative.\n\n    [12, -7, -102, -100] => [12, -102]\n    \"\"\"",
    "sol_bodies": [
      "    def bad(n):\n        s = str(n)\n        return int(s[:2]) + sum(int(c) for c in s[2:]) <= 0\n\n    return [n for n in nums if not bad(n)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#108",
    "weight": 1.0
  },
  {
    "name": "RotateSort:0",
    "sat": "def sat(original: List[int], arr=[2, 3, -1, -1, 0, 1, 1]):\n    assert str(original)[1:-1] in str(sorted(original) * 2), \"Not ring sorted\"\n    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))",
    "ans_type": "List[int]",
    "sol_header": "def sol(arr=[2, 3, -1, -1, 0, 1, 1]):",
    "sol_docstring": "    \"\"\"\n    An array is ring-sorted if it is a \"rotation\" of a non-decreasing list.\n    Remove at most one element from arr to make it ring-sorted.\n\n    [1, 2, 3, -1, 6, 0] => [1, 2, 3, -1, 0]\n    \"\"\"",
    "sol_bodies": [
      "    def sat(near):\n        order_violations = 0\n        erasures = 0\n        for i, n in enumerate(near):\n            if n < near[i - 1]:  # -1 when i =0 gives last element\n                order_violations += 1\n            while n != arr[i + erasures]:\n                erasures += 1\n        return order_violations <= 1 and erasures <= 1\n\n    candidates = [arr] + [arr[:i] + arr[i + 1:] for i in range(len(arr))]\n    return next(near for near in candidates if sat(near))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#109\n\nThis puzzle (and RotateString from #154) use the fact that a string is a rotation of r if it is a substring of r+r",
    "weight": 1.0
  },
  {
    "name": "ParityExchange:0",
    "sat": "def sat(swaps: List[List[int]], nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):\n    copy1 = nums1[:]\n    copy2 = nums2[:]\n    for i, j in swaps:\n        copy1[i], copy2[j] = copy2[j], copy1[i]\n    return all(n % 2 == 0 for n in copy1)",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(nums1=[1, 3, 2, 4, 5, 8, 7, 11], nums2=[0, 7, 0, 8, 19, 4, 41, 43, 42]):",
    "sol_docstring": "    \"\"\"\n    Find a sequence of swaps (indices into two lists) such that, after making those swaps, all numbers in the\n    first list are even\n\n    [1, 3, 4] [2, 4, 5] => [0, 1]\n    \"\"\"",
    "sol_bodies": [
      "    odds = [i for i, n in enumerate(nums1) if n % 2 == 1]\n    evens = [i for i, n in enumerate(nums2) if n % 2 == 0]\n    return [[i, j] for i, j in zip(odds, evens)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#110",
    "weight": 1.0
  },
  {
    "name": "CharCounts:0",
    "sat": "def sat(s: str, counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):\n    chars = s.split()\n    for c in chars:\n        assert chars.count(c) == counts[c]\n    return len(chars) == sum(counts.values())",
    "ans_type": "str",
    "sol_header": "def sol(counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):",
    "sol_docstring": "    \"\"\"Find a string consisting of space-separated characters with given counts\n\n    {\"f\": 1, \"o\": 2} => \"oof\"\n    \"\"\"",
    "sol_bodies": [
      "    return \" \".join(c for c, i in counts.items() for _ in range(i))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#111",
    "weight": 1.0
  },
  {
    "name": "DelPalindrome:0",
    "sat": "def sat(strings: List[str], a=\"this is a test\", b=\"cat\"):\n    s, is_palindrome = strings\n    i = 0\n    for c in a:\n        if c not in b:\n            assert s[i] == c\n            i += 1\n    assert i == len(s)\n    return is_palindrome == str(s == s[::-1])",
    "ans_type": "List[str]",
    "sol_header": "def sol(a=\"this is a test\", b=\"cat\"):",
    "sol_docstring": "    \"\"\"\n    Return a pair of a strings where the first string is the same as a with all the characters of b removed,\n    and the second string is 'True' if this string is a palindrome otherwise 'False'.\n\n    a=\"madam, I'm adam.\" b = \"Yes, we're here.\" => ['madamImadam', 'True']\n    \"\"\"",
    "sol_bodies": [
      "    s = \"\".join(c for c in a if c not in b)\n    return [s, str(s == s[::-1])]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#112",
    "weight": 1.0
  },
  {
    "name": "ReplaceMe:0",
    "sat": "def sat(answers: List[str], lst=['234515', '21503', '2506236943']):\n    if len(answers) != len(lst):\n        return False\n    for a, s in zip(answers, lst):\n        if \"t\" in a:\n            return False\n        num_odds = sum(int(i) % 2 for i in s)\n        if a.replace(str(num_odds), \"t\") != \"this is a test\":\n            return False\n    return True",
    "ans_type": "List[str]",
    "sol_header": "def sol(lst=['234515', '21503', '2506236943']):",
    "sol_docstring": "    \"\"\"For each string in lst, count the number of odd digits. Find a string with no t's such that replacing\n    this number by t gives the string 'this is a test'\n\n    [\"123\", \"2\"] => [\"2his is a 2es2\", \"0his a 0es0\"]\n    \"\"\"",
    "sol_bodies": [
      "    return [\"this is a test\".replace(\"t\", str(sum(c in \"13579\" for c in s))) for s in lst]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#113",
    "weight": 1.0
  },
  {
    "name": "MinSubArraySum:0",
    "sat": "def sat(start_end: List[int], base=7, p=50741, upper=-4897754):\n    start, end = start_end\n    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper",
    "ans_type": "List[int]",
    "sol_header": "def sol(base=7, p=50741, upper=-4897754):",
    "sol_docstring": "    \"\"\"Find the start and end of the smallest-sum subarray of [(base^i mod p) - p/2 for i=start,..., end]\n\n    base=3, p=7, upper =-3 => [0, 3]\n    # because -3 is the sum of the elements [0:3] of [-2, 0, -1, 3, 1, 2, -2, 0, -1, 3 ...\n    \"\"\"",
    "sol_bodies": [
      "    tot = 0\n    best_tot = 0\n    best_end = 0\n    best_start = 0\n    largest_cumulative_sum = 0\n    largest_cumulative_sum_index = 0\n\n    n = 1\n\n    for i in range(p + 1):\n        if tot > largest_cumulative_sum:\n            largest_cumulative_sum = tot\n            largest_cumulative_sum_index = i\n        if tot - largest_cumulative_sum < best_tot:\n            best_tot = tot - largest_cumulative_sum\n            best_start = largest_cumulative_sum_index\n            best_end = i\n\n        tot += (n - p // 2)\n        n = (n * base) % p\n\n    return [best_start, best_end]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#114\n\nThis is harder than \\#1114. The arrays here are chosen to be long enough that the brute-force n^2 algorithm takes\nwhile the O(n) algorithm takes milliseconds.",
    "weight": 1.0
  },
  {
    "name": "Buckets:0",
    "sat": "def sat(wells: List[List[List[int]]], grid=[[1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 0, 1]], capacity=2):\n    grid2 = [[0 for _ in row] for row in grid]\n    for group in wells:\n        assert len(group) <= capacity\n        for i, j in group:\n            assert grid2[i][j] == 0\n            grid2[i][j] = 1\n    assert sum(len(group) != capacity for group in wells) <= 1  # at most one under-capacity group\n    return grid2 == grid",
    "ans_type": "List[List[List[int]]]",
    "sol_header": "def sol(grid=[[1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 0, 1]], capacity=2):",
    "sol_docstring": "    \"\"\"Given a grid, partition the 1's into groups of capacity [x, y] pairs, with at most one incomplete group\"\"\"",
    "sol_bodies": [
      "    ans = []\n    for i, row in enumerate(grid):\n        for j, val in enumerate(row):\n            if val == 1:\n                if not ans or len(ans[-1]) == capacity:\n                    ans.append([])\n                ans[-1].append([i, j])\n    return ans"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#115",
    "weight": 1.0
  },
  {
    "name": "BinarySort:0",
    "sat": "def sat(ordered: List[int], arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):\n    if sorted(ordered) != sorted(arr):\n        return False  # not even a permutation\n    return all(bin(a).count(\"1\") <= bin(b).count(\"1\") for a, b in zip(ordered, ordered[1:]))",
    "ans_type": "List[int]",
    "sol_header": "def sol(arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):",
    "sol_docstring": "    \"\"\"Sort the numbers in arr based on the number of 1's in their binary representation.\n\n    [1, 2, 3, 4, 6] => [1, 2, 4, 3, 6]\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(arr, key=lambda n: bin(n).count(\"1\"))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#116",
    "weight": 1.0
  },
  {
    "name": "ConsonantFilter:0",
    "sat": "def sat(words: List[str], s=\"This is not a very hard puzzle\", n=3):\n    i = 0\n    for w in s.split():\n        num_consonants = 0\n        for c in w.lower():\n            if c not in \"aeiou\":\n                num_consonants += 1\n        if num_consonants == n:\n            if words[i] != w:\n                return False\n            i += 1\n    return i == len(words)",
    "ans_type": "List[str]",
    "sol_header": "def sol(s=\"This is not a very hard puzzle\", n=3):",
    "sol_docstring": "    \"\"\"Find all words in the string with n consonants\n\n    Sample input:\n    s=\"An eye for an I\", n=1\n    Sample output:\n    [\"An\", \"eye\", \"an\"]\n    \"\"\"",
    "sol_bodies": [
      "    return [w for w in s.split() if sum(c.lower() not in \"aeiou\" for c in w) == n]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#117",
    "weight": 1.0
  },
  {
    "name": "VowelSandwich:0",
    "sat": "def sat(ham: str, s=\"Any vowel is OK\"):\n    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons",
    "ans_type": "str",
    "sol_header": "def sol(s=\"Any vowel is OK\"):",
    "sol_docstring": "    \"\"\"Find any vowel sandwich, a string consisting of a vowel between two consonants, contained in s\n\n    \"sandwhich\" => \"hic\"\n    \"\"\"",
    "sol_bodies": [
      "    vows = \"aeiou\"\n    cons = \"bcdfghjklmnpqrstvwxz\"\n    return next(s[i - 1:i + 2] for i in range(1, len(s) - 1)\n                if s[i].lower() in vows and s[i - 1].lower() in cons and s[i + 1].lower() in cons)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#118",
    "weight": 1.0
  },
  {
    "name": "ParenthesesPermutation:0",
    "sat": "def sat(perm: str, s=\"))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  ((((((((((\"):\n    assert sorted(perm.split()) == sorted(s.split()), \"Must be a permutation of the space-delimited 'groups'\"\n    return all(perm[:i].count(\"(\") >= perm[:i].count(\")\") for i in range(len(perm)))",
    "ans_type": "str",
    "sol_header": "def sol(s=\"))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  ((((((((((\"):",
    "sol_docstring": "    \"\"\"The string s consists of groups of parentheses separated by spaces.\n    Permute the groups such that the parentheses match.\n\n    \"( ) )(\" => \"( )( )\"\n    \"\"\"",
    "sol_bodies": [
      "    assert all(c in \"( )\" for c in s)\n    parts = s.split()\n\n    def min_depth(part):\n        \"\"\"Returns the lowest depth <= 0\"\"\"\n        ans = 0\n        depth = 0\n        for c in part:\n            if c == \")\":\n                depth -= 1\n                ans = min(ans, depth)\n            else:\n                depth += 1\n        return ans\n\n    def greedy_reorder(subs):\n        \"\"\"Reorder a bunch of parentheses substrings so as to maintain # ('s > # )'s \"\"\"\n        queue = subs[:]\n        subs[:] = []\n        height = 0\n        while queue:\n            best = max([s for s in queue if min_depth(s) + height >= 0], key=lambda s: s.count(\"(\") - s.count(\")\"))\n            height += best.count(\"(\") - best.count(\")\")\n            subs.append(best)\n            queue.remove(best)\n\n    lefts = [s for s in parts if s.count(\"(\") >= s.count(\")\")]\n\n    greedy_reorder(lefts)\n\n    def mirror(sub):\n        return \"\".join(\")\" if c == \"(\" else \"(\" for c in sub[::-1])\n\n    rights = [mirror(s) for s in parts if s.count(\"(\") < s.count(\")\")]  # mirror temporarily for reordering\n\n    greedy_reorder(rights)\n    return \" \".join(lefts + [mirror(s) for s in rights[::-1]])"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#119\n    \nThis is harder version in which you need to find a permutation of many substrings. Brute force is too slow.",
    "weight": 1.0
  },
  {
    "name": "BiggestK:0",
    "sat": "def sat(biggest: List[int], k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):\n    if len(biggest) != k:\n        return False\n    smallest = nums[:]\n    for n in biggest:\n        smallest.remove(n)\n    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)",
    "ans_type": "List[int]",
    "sol_header": "def sol(k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):",
    "sol_docstring": "    \"\"\"Find the largest k numbers\n\n    k=2, [1, 2, 3, 4, 5, 5, 3, 5, 2] => [5, 5]\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(nums, reverse=True)[:k]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#120",
    "weight": 1.0
  },
  {
    "name": "OddEvenSum:0",
    "sat": "def sat(tot: int, nums=[18, 42152, 125023521, -1221873620123, 17, 19]):\n    for i in nums[::2]:\n        if i % 2 == 1:\n            tot -= i\n    return tot == 0",
    "ans_type": "int",
    "sol_header": "def sol(nums=[18, 42152, 125023521, -1221873620123, 17, 19]):",
    "sol_docstring": "    \"\"\"Find the sum of the odd elements that are at even indices\n\n    [0, 1, 2, 3, 5, 6] => 5\n    \"\"\"",
    "sol_bodies": [
      "    return sum(i for i in nums[::2] if i % 2 == 1)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#121\n\nVery similar to EvenOddSum from \\#85",
    "weight": 1.0
  },
  {
    "name": "LongEarlySum:0",
    "sat": "def sat(tot: int, k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):\n    for n in nums[:k]:\n        if len(str(abs(n))) > 2:\n            tot -= n\n    return tot == 0",
    "ans_type": "int",
    "sol_header": "def sol(k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):",
    "sol_docstring": "    \"\"\"Find the sum of the numbers among the first k with more than 2 digits\n\n    k=3, nums=[2, 102, 12, 1000] => 102\n    \"\"\"",
    "sol_bodies": [
      "    return sum(n for n in nums[:k] if len(str(abs(n))) > 2)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#122\n    \nChanged slightly to make the answer not be a small integer.",
    "weight": 1.0
  },
  {
    "name": "OddCollatz:0",
    "sat": "def sat(odds: List[int], n=1243272912731):\n    num_odds = 0\n    while True:\n        if n % 2 == 1:\n            num_odds += 1\n            if n not in odds:\n                return False\n        if n <= 1:\n            return num_odds == len(odds)\n        n = (3 * n + 1) if n % 2 == 1 else n // 2",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=1243272912731):",
    "sol_docstring": "    \"\"\"Find the odd numbers in the collatz sequence starting at n\n\n    3 => [3, 5, 1]  # because the Collatz sequence starting with 3 is [3, 10, 5, 16, 8, 4, 2, 1]\n    \"\"\"",
    "sol_bodies": [
      "    ans = []\n    while True:\n        if n % 2 == 1:\n            ans.append(n)\n        if n <= 1:\n            return ans\n        n = (3 * n + 1) if n % 2 == 1 else n // 2"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#123",
    "weight": 1.0
  },
  {
    "name": "DateDiff:0",
    "sat": "def sat(s: str, target=-2075):\n    assert all(c in \"0123457689-\" for c in s) and s[2] == s[5] == \"-\"\n    m, d, y = [int(n) for n in s.split(\"-\")]\n    assert m in range(1, 13)\n    assert d in range(1, 32)\n    if m in [4, 6, 9, 11]:\n        assert d <= 30\n    if m == 2:\n        assert d <= 29\n    return m - d - y == target",
    "ans_type": "str",
    "sol_header": "def sol(target=-2075):",
    "sol_docstring": "    \"\"\"Find a valid date mm-dd-yyyy such that the date, viewed as a mathematical expression, evaluates to target\n\n    -2029 => \"10-18-2021\" # because 10-18-2021 == -2029\n    \"\"\"",
    "sol_bodies": [
      "    if target >= -30:\n        return \"12-01-\" + str(11 - target).zfill(4)\n    return \"01-31-\" + str(-30 - target).zfill(4)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#124",
    "weight": 1.0
  },
  {
    "name": "StrangeSplit:0",
    "sat": "def sat(lst: List[str], s=\"Hello, world!\"):\n    if \" \" in s:\n        return \" \".join(lst) == s\n    if \",\" in s:\n        return \",\".join(lst) == s\n    return \"\".join(lst) == \"\".join(c for c in s if c.islower() and ord(c) % 2 == 0)",
    "ans_type": "List[str]",
    "sol_header": "def sol(s=\"Hello, world!\"):",
    "sol_docstring": "    \"\"\"Split s into strings if there is a space in s, otherwise split on commas if there is a comma, otherwise\n    return the list of lowercase letters with odd order (order of a = 0, b = 1, etc.)\n\n    \"a b c\" => [\"a\", \"b\", \"c\"]\n    \"a,b\" => [\"a\", \"b\"]\n    \"\"\"",
    "sol_bodies": [
      "    if \" \" in s:\n        return s.split(\" \")\n    if \",\" in s:\n        return s.split(\",\")\n    return [c for c in s if c.islower() and ord(c) % 2 == 0]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#125",
    "weight": 1.0
  },
  {
    "name": "IncreasingViolation:0",
    "sat": "def sat(violation: List[int], nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):\n    if not violation:\n        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))\n    i, j = violation\n    return 0 <= i < j and nums[i] >= nums[j]",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):",
    "sol_docstring": "    \"\"\"\n    Find the indices of two entries that show that the list is not in increasing order.\n    If there are no violations (they are increasing), return an empty list.\n\n    [1,2,3,0,4,5,6] => [1, 3]\n    \"\"\"",
    "sol_bodies": [
      "    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return [i, i + 1]\n    return []"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#126",
    "weight": 1.0
  },
  {
    "name": "PrimeIntervalIntersection:0",
    "sat": "def sat(interval2: List[int], interval1=[32157, 93210127]):\n    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])\n    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))",
    "ans_type": "List[int]",
    "sol_header": "def sol(interval1=[32157, 93210127]):",
    "sol_docstring": "    \"\"\"Find an interval whose intersection with a given interval has a width that is a prime integer.\n\n    [7, 100] => [0, 10]  # because 10-7=3 is prime\n    \"\"\"",
    "sol_bodies": [
      "    a, b = interval1\n    assert b - a >= 2\n    return [a, a + 2]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#127",
    "weight": 1.0
  },
  {
    "name": "ProductSigns:0",
    "sat": "def sat(n: int, arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):\n    tot = 0\n\n    for i in arr:\n        if tot >= 0:\n            tot += abs(i)\n        else:\n            tot -= abs(i)\n        if i < 0:\n            tot = -tot\n        elif i == 0:\n            tot = 0\n            break\n\n    return n == tot",
    "ans_type": "int",
    "sol_header": "def sol(arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):",
    "sol_docstring": "    \"\"\"Find the sum of the magnitudes of the elements in the array with a sign that is equal to the product of\n    the signs of the entries.\n\n    [1, -2, 3] => -6  # negative because there is one negative\n    \"\"\"",
    "sol_bodies": [
      "    tot = sum(abs(i) for i in arr)\n    if all(arr):\n        return tot if sum(i < 0 for i in arr) % 2 == 0 else -tot\n    return 0"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#128\n    \nEasy puzzle since the answer is computed in the puzzle, but it is okay to have a few trivial puzzles.",
    "weight": 1.0
  },
  {
    "name": "LexPath:0",
    "sat": "def sat(path: List[int], k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):\n\n    def check(prefix):\n        for i, j in zip(path, prefix):\n            if i != j:\n                return i < j\n        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])\n\n    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))",
    "ans_type": "List[int]",
    "sol_header": "def sol(k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):",
    "sol_docstring": "    \"\"\"Find the lexicographically smallest path of length k in graph with given edge matrix (and no dead ends)\n\n    k=3, edges=[[1,3], [0, 3], [2], [3]] => [0, 1, 0] # because 0-1 and 1-0 are edges\n    \"\"\"",
    "sol_bodies": [
      "    path = []\n    while len(path) < k:\n        path.append(min(edges[path[-1]]) if path else 0)\n    return path"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#129",
    "weight": 1.0
  },
  {
    "name": "Tribonacci:0",
    "sat": "def sat(seq: List[int], length=181):\n    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))",
    "ans_type": "List[int]",
    "sol_header": "def sol(length=181):",
    "sol_docstring": "    \"\"\"Find a sequence where seq[n] == 1 + n / 2 for even n, and\n    seq[n] == seq[n - 1] + seq[n - 2] + seq[n + 1] for odd n < length.\"\"\"",
    "sol_bodies": [
      "    seq = []\n    while len(seq) <= length:\n        n = len(seq)\n        if n % 2 == 0:\n            seq.append(1 + n // 2)\n        else:\n            seq.append(sum(seq[-2:]) + (1 + (n + 1) // 2))\n    return seq + [0]  # appending 0 at the end makes it easier so that seq[n-2] == 0 for n == 1"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#130\n\nThis puzzle is a bit harder because the definition is slightly different at seq[1].",
    "weight": 1.0
  },
  {
    "name": "OddProduct:0",
    "sat": "def sat(prod: int, n=14235764939971075543215213):\n\n    for c in str(n):\n        i = int(c)\n        if i % 2 == 1:\n            assert prod % i == 0\n            prod //= i\n    return prod == any(int(c) % 2 for c in str(n))",
    "ans_type": "int",
    "sol_header": "def sol(n=14235764939971075543215213):",
    "sol_docstring": "    \"\"\"Return the product of the odd digits in n, or 0 if there aren't any\n\n    12345 => 15\n    \"\"\"",
    "sol_bodies": [
      "    if any(int(c) % 2 for c in str(n)):\n        prod = 1\n        for c in str(n):\n            if int(c) % 2 == 1:\n                prod *= int(c)\n        return prod\n    return 0"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#131",
    "weight": 1.0
  },
  {
    "name": "ValidBracketSubsequence:0",
    "sat": "def sat(valid: str, s=\"]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[[\"):\n    assert valid in s\n    depths = [0]\n    for c in valid:\n        if c == \"[\":\n            depths.append(depths[-1] + 1)\n        elif c == \"]\":\n            depths.append(depths[-1] - 1)\n    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1",
    "ans_type": "str",
    "sol_header": "def sol(s=\"]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[[\"):",
    "sol_docstring": "    \"\"\"Find a valid substring of s that contains matching brackets, at least one of which is nested\n\n    \"]][][[]]]\" => \"[][[]]\"\n    \"\"\"",
    "sol_bodies": [
      "    left = []\n    nested = False\n    for i, c in enumerate(s):\n        if c == \"[\":\n            if len(left) == 2:\n                left = [left[1], i]\n                nested = False\n            else:\n                left.append(i)\n        elif c == \"]\":\n            if not left:\n                continue\n            if len(left) == 1 and nested:\n                return s[left[0]:i + 1]\n            elif len(left) == 2:\n                nested = True\n            left.pop()\n    assert False",
      "    import re\n    return re.search(r\"\\[(\\[\\])+\\]\", s).group(0)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#132",
    "weight": 1.0
  },
  {
    "name": "CeilingSquares:0",
    "sat": "def sat(running_squares: List[int], x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):\n    for i, v in enumerate(x):\n        ceiling = int(v) + (v > 0 and not v.is_integer())\n        square = ceiling ** 2\n        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):\n            return False\n\n    return len(running_squares) == len(x)",
    "ans_type": "List[int]",
    "sol_header": "def sol(x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):",
    "sol_docstring": "    \"\"\"Round each float in x up to the next integer and return the running total of the integer squares\n\n    [2.4, 3.7, 0.1] => [9, 25, 26]\n    \"\"\"",
    "sol_bodies": [
      "    from math import ceil\n    running_squares = []\n    tot = 0\n    for v in x:\n        tot += ceil(v) ** 2\n        running_squares.append(tot)\n    return running_squares"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#133",
    "weight": 1.0
  },
  {
    "name": "LastLetters:0",
    "sat": "def sat(y: List[bool], x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):\n    assert len(x) == len(y)\n    for s, b in zip(x, y):\n        if len(s.split(\" \")[-1]) == 1:\n            assert b == s[-1].isalpha()\n        else:\n            assert not b\n    return True",
    "ans_type": "List[bool]",
    "sol_header": "def sol(x=['Hello, world!', 'cat', '', 'a test', 'test a', 'i e', 'o', 'I O U', 'You and I']):",
    "sol_docstring": "    \"\"\"Determine, for each string in x, whether the last character is an isolated letter\n\n    [\"a b c\", \"abc\"] => [True, False]\n    \"\"\"",
    "sol_bodies": [
      "    return [len(s.split(\" \")[-1]) == 1 and s[-1].isalpha() for s in x]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#134",
    "weight": 1.0
  },
  {
    "name": "Drops:0",
    "sat": "def sat(drop_indexes: List[int], nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):\n    d = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            assert drop_indexes[d] == i\n            d += 1\n    return d == len(drop_indexes)",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):",
    "sol_docstring": "    \"\"\"Find the indices for which the nums array drops.\n\n    [1,2,3,0,2,4,1] => [3,6]\n    \"\"\"",
    "sol_bodies": [
      "    return [i for i in range(1, len(nums)) if nums[i] < nums[i - 1]]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#135",
    "weight": 1.0
  },
  {
    "name": "LargestNegSmallestPos:0",
    "sat": "def sat(extremes: List[int], nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):\n    neg, pos = extremes\n    if neg == 0:\n        assert nums == [] or min(nums) >= 0\n    else:\n        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)\n    if pos == 0:\n        assert nums == [] or max(nums) <= 0\n    else:\n        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):",
    "sol_docstring": "    \"\"\"Find the largest negative ans smallest positive numbers (or 0 if none)\n\n    [-2, -4, 14, 50] => [-2, 14]\n    [3, 22] => [0, 3]\n    \"\"\"",
    "sol_bodies": [
      "    pos = [n for n in nums if n > 0]\n    neg = [n for n in nums if n < 0]\n    return [max(neg) if neg else 0, min(pos) if pos else 0]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#136",
    "weight": 1.0
  },
  {
    "name": "LargestStringNum:0",
    "sat": "def sat(x: float, str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):\n    found = False\n    for s in str_nums:\n        y = float(s.replace(\",\", \".\"))\n        assert y <= x\n        if y == x:\n            found = True\n    return found",
    "ans_type": "float",
    "sol_header": "def sol(str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):",
    "sol_docstring": "    \"\"\"Find the largest number where commas or periods are decimal points\n\n    [\"99,9\", \"100\"] => 100.0\n    \"\"\"",
    "sol_bodies": [
      "    return max(float(s.replace(\",\", \".\")) for s in str_nums)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#137",
    "weight": 1.0
  },
  {
    "name": "Even4Sum:0",
    "sat": "def sat(summands: List[int], n=1234567890):\n    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=1234567890):",
    "sol_docstring": "    \"\"\"Find four positive even integers whose sum is n\n\n    100 => [22, 24, 26, 28]\"\"\"",
    "sol_bodies": [
      "    return [2] * 3 + [n - 6]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#138",
    "weight": 1.0
  },
  {
    "name": "InverseSuperFactorial:0",
    "sat": "def sat(nums: List[int], super_factorials=[1, 2, 1]):\n    for i, sf in enumerate(super_factorials):\n        n = nums[i]\n        for j in range(n, 0, -1):\n            k = j ** (n - j + 1)\n            assert sf % k == 0, f\"{i} {sf} {j} {n}\"\n            sf //= k\n        assert sf == 1\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(super_factorials=[1, 2, 1]):",
    "sol_docstring": "    \"\"\"The super-factorial of n is n! (n-1)! (n-2)! ... 1!. Invert a given list of super-factorials.\n\n    [1, 2, 2, 12] => [1, 2, 2, 3]\n    \"\"\"",
    "sol_bodies": [
      "    queue = set(super_factorials)\n    cache = {}\n    n = 1\n    fact = 1\n    s_fact = 1\n    while queue:\n        fact *= n\n        s_fact *= fact\n        if s_fact in queue:\n            queue.remove(s_fact)\n            cache[s_fact] = n\n        n += 1\n    return [cache[sf] for sf in super_factorials]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#139",
    "weight": 1.0
  },
  {
    "name": "ExpandSpaces:0",
    "sat": "def sat(orig: str, target=\"-Hello,_world!__This_is-so-easy!-\"):\n    assert \"_\" not in orig and \"-\" not in orig\n    new = \"\"\n    space_count = 0\n    for c in orig:\n        if c == \" \":\n            space_count += 1\n        else:\n            new += (\"-\" if space_count > 2 else \"_\" * space_count)\n            new += c\n            space_count = 0\n    new += (\"-\" if space_count > 2 else \"_\" * space_count)\n    return new == target",
    "ans_type": "str",
    "sol_header": "def sol(target=\"-Hello,_world!__This_is-so-easy!-\"):",
    "sol_docstring": "    \"\"\"Find a string such that, when three or more spaces are compacted to a '-' and one or two spaces are\n    replaced by underscores, leads to the target.\n\n    \"_o-k__?-\" => \"  o        k  ?     \"\n    \"\"\"",
    "sol_bodies": [
      "    return target.replace(\"-\", \" \" * 3).replace(\"_\", \" \")"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#140",
    "weight": 1.0
  },
  {
    "name": "FilenameOK:0",
    "sat": "def sat(valids: List[str], filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):\n    assert len(valids) == len(filenames)\n    for v, f in zip(valids, filenames):\n        n_digits = sum(c.isdigit() for c in f)\n        if v == \"Yes\":\n            prefix, ext = f.split(\".\")\n            assert ext in [\"txt\", \"dll\", \"exe\"] and prefix[0].isalpha() and n_digits < 4\n        else:\n            assert v == \"No\"\n            assert f.split(\".\")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3\n    return True",
    "ans_type": "List[str]",
    "sol_header": "def sol(filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):",
    "sol_docstring": "    \"\"\"Return a list of Yes/No strings that determine whether candidate filename is valid. A valid filename\n    should end in .txt, .exe, or .dll, and should have at most three digits, no additional periods\n\n    [\"train.jpg\", \"doc10234.txt\", \"3eadme.txt\"] = [\"No\", \"No\", \"Yes\"]\n    \"\"\"",
    "sol_bodies": [
      "    return [\"Yes\" if\n            f.split(\".\")[1:] in [['txt'], ['dll'], ['exe']] and f[0].isalpha() and sum(c.isdigit() for c in f) < 4\n            else \"No\"\n            for f in filenames]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#141",
    "weight": 1.0
  },
  {
    "name": "FindStrangeSum:0",
    "sat": "def sat(lst: List[int], tot=1125181293221):\n    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot",
    "ans_type": "List[int]",
    "sol_header": "def sol(tot=1125181293221):",
    "sol_docstring": "    \"\"\"Find a list of integers such that tot is the sum of (n^2 if 3 | n, else n^3 if 4 | n, else n)\"\"\"",
    "sol_bodies": [
      "    residue = (tot - 1) % 12\n    return [1] * residue + [tot - residue]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#142",
    "weight": 1.0
  },
  {
    "name": "PrimeWords:0",
    "sat": "def sat(primes: str, s=\"This is a test of whether you would want to do such strange puzzles\"):\n\n    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    prime_words = primes.split()\n    i = 0\n    for word in s.split():\n        if is_prime(len(word)):\n            assert prime_words[i] == word\n            i += 1\n\n    return i == len(prime_words)",
    "ans_type": "str",
    "sol_header": "def sol(s=\"This is a test of whether you would want to do such strange puzzles\"):",
    "sol_docstring": "    \"\"\"Find the string consisting of all the words whose lengths are prime numbers\n\n    \"A bird in the hand is worth two in the bush\" => \"in the is worth two in the\"\n    \"\"\"",
    "sol_bodies": [
      "    def is_prime(n):\n        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))\n\n    return \" \".join(w for w in s.split() if is_prime(len(w)))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#143",
    "weight": 1.0
  },
  {
    "name": "SimplifyProductFraction:0",
    "sat": "def sat(z: str, x=\"-8142432/763083\", y=\"66/-13474\", max_len=18):\n    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split(\"/\")] for s in [x, y, z]]\n    return a * c * v == b * d * u and len(z) <= max_len",
    "ans_type": "str",
    "sol_header": "def sol(x=\"-8142432/763083\", y=\"66/-13474\", max_len=18):",
    "sol_docstring": "    \"\"\"Write x * y as the shortest equivalent fraction using at most max_len chars\n\n    x=\"-2/3\", y=\"-3/8\", max_len=3 => \"1/4\"\n    \"\"\"",
    "sol_bodies": [
      "    [[a, b], [c, d]] = [[int(n) for n in s.split(\"/\")] for s in [x, y]]\n    num, den = a * c, b * d\n    if num < 0 and den < 0:\n        num, den = -num, -den\n    if num == 0:\n        return \"0/1\"\n\n    def gcd(a, b):\n        a, b = min(a, b), max(a, b)\n        if b % a == 0:\n            return a\n        return gcd(b % a, a)\n\n    d = gcd(abs(num), abs(den))\n    return f'{num // d}/{den // d}'"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#144",
    "weight": 1.0
  },
  {
    "name": "SortByDigitSum:0",
    "sat": "def sat(ordered: List[int], nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):\n    digit_sums = [sum(int(c) for c in str(n) if c != \"-\") for n in ordered]\n    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):",
    "sol_docstring": "    \"\"\"Sort the numbers by the sum of their digits\n\n    [17, 21, 0] => [0, 17, 21]\n    \"\"\"",
    "sol_bodies": [
      "    return sorted(nums, key=lambda n: sum(int(c) for c in str(n) if c != \"-\"))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#145",
    "weight": 1.0
  },
  {
    "name": "BigOdds:0",
    "sat": "def sat(odds: List[int], nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):\n    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])\n    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):",
    "sol_docstring": "    \"\"\"Find the numbers that are greater than 10 and have odd first and last digits\n\n    [73, 4, 72] => [73]\n    \"\"\"",
    "sol_bodies": [
      "    return [n for n in nums if n > 10 and (int(str(n)[0]) * int(str(n)[-1])) % 2]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#146",
    "weight": 1.0
  },
  {
    "name": "Threeples:0",
    "sat": "def sat(trips: List[List[int]], a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):\n    assert len({tuple(t) for t in trips}) >= count\n    return all(0 <= i < j < k and (a[i] + a[j] + a[k]) % 3 == 0 for i, j, k in trips)",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(a=[1, 0, -17, 42, 321, 36, 429, 35, 10, 923, 35, 18, 0, 17, 24, 32, 8], count=221):",
    "sol_docstring": "    \"\"\"Find all triples of increasing indices where the sum of the numbers is divisible by three\n\n    a=[1, 2, 4, 8, 14, 10], count=2 => [[0, 2, 5], [1, 3, 4]] = > because 1 + 4 + 10, 2 + 8 + 14 are divisible by 3\n    \"\"\"",
    "sol_bodies": [
      "    n = len(a)\n    return [[i, j, k] for k in range(2, n) for j in range(k) for i in range(j) if (a[i] + a[j] + a[k]) % 3 == 0]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#147",
    "weight": 1.0
  },
  {
    "name": "PlanetRange:0",
    "sat": "def sat(planets_between: List[str], a=\"Mars\", b=\"Neptune\"):\n    assert \" \" not in \"\".join(planets_between)\n    return \" \".join([a] + planets_between + [b]) in \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\"",
    "ans_type": "List[str]",
    "sol_header": "def sol(a=\"Mars\", b=\"Neptune\"):",
    "sol_docstring": "    \"\"\"Find all planets between the two given planets\n\n    a=\"Jupiter\", b=\"Pluto\" => [\"Saturn\" \"Uranus\" \"Neptune\"]\n    \"\"\"",
    "sol_bodies": [
      "    planets = \"Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\".split()\n    return planets[planets.index(a) + 1:planets.index(b)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#148",
    "weight": 1.0
  },
  {
    "name": "EvenWords:0",
    "sat": "def sat(evens: List[str], words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):\n    lens = [len(w) for w in evens]\n    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))\n    return all((len(w) % 2 == 1 or w in evens) for w in words)",
    "ans_type": "List[str]",
    "sol_header": "def sol(words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):",
    "sol_docstring": "    \"\"\"Find the even-length words and sort them by length.\n\n    [\"soup\", \"not\", \"splendid\"] => [\"soup\", \"splendid\"]\n    \"\"\"",
    "sol_bodies": [
      "    return sorted([w for w in words if len(w) % 2 == 0], key=lambda w: (len(w), w))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#149",
    "weight": 1.0
  },
  {
    "name": "PrimeSel:0",
    "sat": "def sat(neighbors: List[int], nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):\n\n    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    goods = set()\n    for i, n in enumerate(nums):\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):\n            goods.add(n)\n\n    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):",
    "sol_docstring": "    \"\"\"Find a list of all numbers that are adjacent to a prime number in the list, sorted without duplicates\n\n    [2, 17, 16, 0, 6, 4, 5] => [2, 4, 16, 17]\"\"\"",
    "sol_bodies": [
      "    def prime(m):\n        return all(m % i for i in range(2, m - 1))\n\n    return sorted({\n        n for i, n in enumerate(nums)\n        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1]))\n    })"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#150",
    "weight": 1.0
  },
  {
    "name": "EvenSqure:0",
    "sat": "def sat(tot: int, xs=[123.0, 872322.0, 542.2, -127.5, 18214.0, 3732.4, 12832.4, 23523800.0]):\n    for x in xs:\n        if x.is_integer() and x > 0 and x % 2 == 0:\n            tot -= int(x) ** 2\n\n    return tot == 0",
    "ans_type": "int",
    "sol_header": "def sol(xs=[123.0, 872322.0, 542.2, -127.5, 18214.0, 3732.4, 12832.4, 23523800.0]):",
    "sol_docstring": "    \"\"\"Find the sum of the squares of the positive even integers\n\n    [2.0, 3.0, 2.5, 4.0] => 20\n    \"\"\"",
    "sol_bodies": [
      "    return sum(int(x) ** 2 for x in xs if x.is_integer() and x > 0 and x % 2 == 0)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#151",
    "weight": 1.0
  },
  {
    "name": "ArrayDiff:0",
    "sat": "def sat(b: List[int], a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):\n    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))",
    "ans_type": "List[int]",
    "sol_header": "def sol(a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):",
    "sol_docstring": "    \"\"\"Find an array that when added to vector a gives array vector c\n\n    [1, 2, 3], [4, 17, 5] => [3, 15, 2]\n    \"\"\"",
    "sol_bodies": [
      "    return [k - i for i, k in zip(a, c)]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#152",
    "weight": 1.0
  },
  {
    "name": "StrongestExtension:0",
    "sat": "def sat(s: str, class_name=\"TestClass\", extensions=['extEnd', 'LOL', 'SuPeRbLy', 'v9ACLQWTEW', 'PickMe', 'AI']):\n    assert s.startswith(class_name + \".\")\n    ext = s[len(class_name) + 1:]\n\n    def case_delta(x: str):\n        tot = 0\n        for c in x:\n            if c.isupper():\n                tot += 1\n            elif c.islower():\n                tot -= 1\n        return tot\n\n    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])",
    "ans_type": "str",
    "sol_header": "def sol(class_name=\"TestClass\", extensions=['extEnd', 'LOL', 'SuPeRbLy', 'v9ACLQWTEW', 'PickMe', 'AI']):",
    "sol_docstring": "    \"\"\"Find the class_name.extension for the extension that has the largest #capitals - #lowercase letters\"\"\"",
    "sol_bodies": [
      "    def case_delta(x: str):\n        tot = 0\n        for c in x:\n            if c.isupper():\n                tot += 1\n            elif c.islower():\n                tot -= 1\n        return tot\n\n    return class_name + \".\" + max(extensions, key=case_delta)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#153",
    "weight": 1.0
  },
  {
    "name": "RotateString:0",
    "sat": "def sat(r: str, s=\"light star\", t=\"I love to look at the starlight!\"):\n    return r in t and len(r) == len(s) and r in s + s",
    "ans_type": "str",
    "sol_header": "def sol(s=\"light star\", t=\"I love to look at the starlight!\"):",
    "sol_docstring": "    \"\"\"Find a rotation of string s that is a substring of t\n\n    Input Example:\n    s=\"test\", t=\"I love lattes\"\n\n    Output Example:\n    \"ttes\"\n    \"\"\"",
    "sol_bodies": [
      "    return next(s[i:] + s[:i] for i in range(len(s)) if s[i:] + s[:i] in t)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#154\n\nThis puzzle (and RotateSort from #109) use the fact that a string is a rotation of r if it is a substring of r+r",
    "weight": 1.0
  },
  {
    "name": "EvenOddDigits:0",
    "sat": "def sat(n: int, evens=17, odds=3):\n    for c in str(n):\n        if int(c) % 2 == 0:\n            evens -= 1\n        else:\n            odds -= 1\n    return evens == 0 and odds == 0",
    "ans_type": "int",
    "sol_header": "def sol(evens=17, odds=3):",
    "sol_docstring": "    \"\"\"Find an integer n >= 0 with the given number of even and odd digits.\n\n    evens=3, odds=4 => 2381695\"\"\"",
    "sol_bodies": [
      "    return int(\"2\" * evens + \"1\" * odds)"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#155",
    "weight": 1.0
  },
  {
    "name": "RomanNumerals:0",
    "sat": "def sat(roman: str, n=2414):\n    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n           1: 'i'}\n    m = 0\n    for base in [1000, 100, 10, 1]:\n        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4\n            val = base * mul\n            if val in key and roman.startswith(key[val]):\n                m += val\n                roman = roman[len(key[val]):]\n                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else\n                    break\n    return m == n",
    "ans_type": "str",
    "sol_header": "def sol(n=2414):",
    "sol_docstring": "    \"\"\"Convert integer 0 < n < 4000 to roman numerals, and make it lowercase\n\n    11 => \"xi\"\n    \"\"\"",
    "sol_bodies": [
      "    units = dict(m=1000, cm=900, d=500, cd=400, c=100, xc=90, l=50, xl=40, x=10, ix=9, v=5, iv=4, i=1)\n    roman = \"\"\n    for s, i in units.items():\n        while n >= i:\n            roman += s\n            n -= i\n    return roman"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#156\n    \nDo not add a reverse puzzle converting roman numerals to arabic numbers as it would give away the solution.",
    "weight": 1.0
  },
  {
    "name": "PythagoreanTriples:0",
    "sat": "def sat(triples: List[List[int]], n=920, m=799):\n    for a, b, c in triples:\n        if not (a * a + b * b == c * c and 0 < a < b < c <= n):\n            return False\n    return triples == sorted(triples) and len(triples) >= m",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(n=920, m=799):",
    "sol_docstring": "    \"\"\"Find m Pythagorean triples a^2 + b^2 == c^2 for integers 0 < a < b < c <= n, in sorted order\n\n    (n=6, m=1) => [[3, 4, 5]]\n    \"\"\"",
    "sol_bodies": [
      "    return [[a, b, int((a * a + b * b) ** 0.5)]\n            for a in range(3, int(n / (2 ** 0.5)))\n            for b in range(a + 1, int((n * n - a * a) ** 0.5) + 1)\n            if ((a * a + b * b) ** 0.5).is_integer()]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#157",
    "weight": 1.0
  },
  {
    "name": "MostUnique:0",
    "sat": "def sat(s: str, pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):\n    assert s in pool\n    n = len(set(s))\n    for p in pool:\n        assert len(set(p)) <= n\n    return True",
    "ans_type": "str",
    "sol_header": "def sol(pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):",
    "sol_docstring": "    \"\"\"Select a string from the pool with the most unique characters\n\n    [\"woooow\", \"cow\"] => \"cow\"\n    \"\"\"",
    "sol_bodies": [
      "    return max(pool, key=lambda x: len(set(x)))"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#158",
    "weight": 1.0
  },
  {
    "name": "HungryRabbits:0",
    "sat": "def sat(results: List[List[int]], stats=[[2, 3, 18], [4, 9, 2], [2, 5, 7], [3, 8, 12], [4, 9, 106]]):\n    assert len(results) == len(stats)\n    for (tot, remaining), (eaten, need, stock) in zip(results, stats):\n        assert tot - eaten == min(need, stock)\n        assert stock < need and remaining == 0 or stock >= need and remaining + need == stock\n    return True",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(stats=[[2, 3, 18], [4, 9, 2], [2, 5, 7], [3, 8, 12], [4, 9, 106]]):",
    "sol_docstring": "    \"\"\"For each triple of eaten, need, stock return a pair of total appetite and remaining\n\n    [[2, 5, 6], [3, 9, 22]] => [[7, 1], [12, 13]]\n    \"\"\"",
    "sol_bodies": [
      "    results = []\n    for (eaten, need, stock) in stats:\n        results.append([eaten + min(need, stock), max(0, stock - need)])\n    return results"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#159",
    "weight": 1.0
  },
  {
    "name": "EvaluateOperators:0",
    "sat": "def sat(ops: List[str], target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):\n    assert len(ops) == len(set(ops)) and set(ops) == {\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"}\n    expr = str(nums[0])\n    for n, op in zip(nums[1:], ops):\n        expr += op + str(n)\n    return eval(expr) == target",
    "ans_type": "List[str]",
    "sol_header": "def sol(target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):",
    "sol_docstring": "    \"\"\"Find a permutation of the operators +-*/^% which when inserted between nums evaluates to target\n\n    target=3, nums=[7, 2, 3, 4, 5, 1, 6] => [\"+\", \"*\", \"**\", \"%\", \"//\", \"-\"]\n                                            # because 7 + 2 * 3 ** 4 % 5 // 1 - 6 == 3\n    \"\"\"",
    "sol_bodies": [
      "    from itertools import permutations\n    for ops in permutations([\"**\", \"*\", \"+\", \"-\", \"//\", \"%\"]):\n        expr = str(nums[0])\n        for n, op in zip(nums[1:], ops):\n            expr += op + str(n)\n        try:\n            if eval(expr) == target:\n                return list(ops)\n        except (ZeroDivisionError, SyntaxError):\n            pass\n    assert False"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#160",
    "weight": 1.0
  },
  {
    "name": "ReverseCase:0",
    "sat": "def sat(rev: List[str], strs=['cat', 'u8u', '12532', '', '191', '4tUn8', 'ewrWQTEW', 'i', 'IoU']):\n    assert len(rev) == len(strs)\n    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))",
    "ans_type": "List[str]",
    "sol_header": "def sol(strs=['cat', 'u8u', '12532', '', '191', '4tUn8', 'ewrWQTEW', 'i', 'IoU']):",
    "sol_docstring": "    \"\"\"Reverse the case of all strings. For those strings which contain no letters, reverse the strings.\n\n    [\"Test\", \"!@#\"] => [\"tEST\", \"#@!\"]\n    \"\"\"",
    "sol_bodies": [
      "    return [s.swapcase() if s.swapcase() != s else s[::-1] for s in strs]"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#161",
    "weight": 1.0
  },
  {
    "name": "ZobristCollision:0",
    "sat": "def sat(positions: List[List[int]]):\n\n    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]\n\n    def zobrist(pos):\n        h = 0\n        for i in range(64):\n            if pos[i]:\n                h ^= table[i][pos[i]]\n        return h\n\n    a, b = positions\n    return zobrist(a) == zobrist(b) and a != b",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a collision for the given Zobrist chess board hash: https://en.wikipedia.org/wiki/Zobrist_hashing\n\n    Each of the two positions should be encoded as a list of 64 integers 0-12\"\"\"",
    "sol_bodies": [
      "    hashes = {}\n    table = [[(i * 429436219 + j * 100239120) % 63491564 for j in range(13)] for i in range(64)]\n\n    def zobrist(pos):\n        h = 0\n        for i in range(64):\n            if pos[i]:\n                h ^= table[i][pos[i]]\n        return h\n\n    for i in range(1, 100000000):\n        pos = [(i * 42 + ((i + 1) * j * 12589) % 54321) % 13 for j in range(64)]  # pseudo-random board\n        h = zobrist(pos)\n        if h in hashes:\n            return [pos, hashes[h]]\n        else:\n            hashes[h] = pos"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#162\n\nThe original problem was to compute an MD5 hash. This puzzle is a problem in the space of hashing, but of a\ndifferent nature.",
    "weight": 1.0
  },
  {
    "name": "EvenBetween:0",
    "sat": "def sat(ab: List[int], s=\"3298832990329923299432996329983300033002\"):\n    return abs(ab[0] - ab[1]) > 4 and s == \"\".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)",
    "ans_type": "List[int]",
    "sol_header": "def sol(s=\"3298832990329923299432996329983300033002\"):",
    "sol_docstring": "    \"\"\"Find integers [a, b] that are at least 5 apart and such that concatenating the even numbers\n    between them gives the string s\n\n    \"32343638\" => [31, 38]\n    \"\"\"",
    "sol_bodies": [
      "    for i in range(1, len(s)):\n        n = int(s[:i])\n        n -= (n + 1) % 2  # make n odd\n        m = n + 1  # next even\n        t = \"\"\n        while len(t) < len(s):\n            t += str(m)\n            m += 2\n        if s == t:\n            return [n, m - 1]\n\n    assert False"
    ],
    "module": "human_eval.py",
    "notes": "Inspired by [HumanEval](https://github.com/openai/human-eval) \\#163\n\nThe original problem was trivial to list the even single-digit numbers between two numbers:\n`a=2, b=12` => `[4, 6, 8]`. In this puzzle, we consider the string of even numbers formed when counting from\n`a` to `b`, e.g., `\"1618202224262830\"` when counting from `15` to `30`. The puzzle is, given such a string,\nfind `a` and `b`.",
    "weight": 1.0
  },
  {
    "name": "IsEven:0",
    "sat": "def sat(b: bool, n=10):\n    i = 0\n    while i <= n:\n        if i + i == n:\n            return b == True\n        i += 1\n    return b == False",
    "ans_type": "bool",
    "sol_header": "def sol(n=10):",
    "sol_docstring": "    \"\"\"Determine if n can be evenly divided into two equal numbers. (Easy)\"\"\"",
    "sol_bodies": [
      "    return n % 2 == 0"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 4 A](https://codeforces.com/problemset/problem/4/A)",
    "weight": 1.0
  },
  {
    "name": "Abbreviate:0",
    "sat": "def sat(s: str, word=\"antidisestablishmentarianism\", max_len=10):\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]",
    "ans_type": "str",
    "sol_header": "def sol(word=\"antidisestablishmentarianism\", max_len=10):",
    "sol_docstring": "    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"",
    "sol_bodies": [
      "    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 71 A](https://codeforces.com/problemset/problem/71/A)",
    "weight": 1.0
  },
  {
    "name": "SquareTiles:0",
    "sat": "def sat(corners: List[List[int]], m=10, n=9, a=5, target=4):\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=10, n=9, a=5, target=4):",
    "sol_docstring": "    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"",
    "sol_bodies": [
      "    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 1 A](https://codeforces.com/problemset/problem/1/A)",
    "weight": 1.0
  },
  {
    "name": "EasyTwos:0",
    "sat": "def sat(lb: List[bool], trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))",
    "ans_type": "List[bool]",
    "sol_header": "def sol(trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):",
    "sol_docstring": "    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"",
    "sol_bodies": [
      "    return [sum(s) >= 2 for s in trips]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 231 A](https://codeforces.com/problemset/problem/231/A)",
    "weight": 1.0
  },
  {
    "name": "DecreasingCountComparison:0",
    "sat": "def sat(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])",
    "ans_type": "int",
    "sol_header": "def sol(scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):",
    "sol_docstring": "    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"",
    "sol_bodies": [
      "    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 158 A](https://codeforces.com/problemset/problem/158/A)",
    "weight": 1.0
  },
  {
    "name": "VowelDrop:0",
    "sat": "def sat(t: str, s=\"Problems\"):\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)",
    "ans_type": "str",
    "sol_header": "def sol(s=\"Problems\"):",
    "sol_docstring": "    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 118 A](https://codeforces.com/problemset/problem/118/A)",
    "weight": 1.0
  },
  {
    "name": "DominoTile:0",
    "sat": "def sat(squares: List[List[int]], m=10, n=5, target=50):\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=10, n=5, target=50):",
    "sol_docstring": "    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"",
    "sol_bodies": [
      "    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 50 A](https://codeforces.com/problemset/problem/50/A)",
    "weight": 1.0
  },
  {
    "name": "IncDec:0",
    "sat": "def sat(n: int, ops=['x++', '--x', '--x'], target=19143212):\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target",
    "ans_type": "int",
    "sol_header": "def sol(ops=['x++', '--x', '--x'], target=19143212):",
    "sol_docstring": "    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"",
    "sol_bodies": [
      "    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 282 A](https://codeforces.com/problemset/problem/282/A)\n\nThis straightforward problem is a little harder than the Codeforces one.",
    "weight": 1.0
  },
  {
    "name": "CompareInAnyCase:0",
    "sat": "def sat(n: int, s=\"aaAab\", t=\"aAaaB\"):\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False",
    "ans_type": "int",
    "sol_header": "def sol(s=\"aaAab\", t=\"aAaaB\"):",
    "sol_docstring": "    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"",
    "sol_bodies": [
      "    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 112 A](https://codeforces.com/problemset/problem/112/A)",
    "weight": 1.0
  },
  {
    "name": "SlidingOne:0",
    "sat": "def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):\n    matrix = [m[:] for m in matrix]  # copy\n    for c in s:\n        if c in \"01234\":\n            i = \"01234\".index(c)\n            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]\n        if c in \"abcde\":\n            j = \"abcde\".index(c)\n            for row in matrix:\n                row[j], row[j + 1] = row[j + 1], row[j]\n\n    return len(s) <= max_moves and matrix[2][2] == 1",
    "ans_type": "str",
    "sol_header": "def sol(matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):",
    "sol_docstring": "    \"\"\"\n    We are given a 5x5 matrix with a single 1 like:\n\n    0 0 0 0 0\n    0 0 0 0 1\n    0 0 0 0 0\n    0 0 0 0 0\n    0 0 0 0 0\n\n    Find a (minimal) sequence of row and column swaps to move the 1 to the center. A move is a string\n    in \"0\"-\"4\" indicating a row swap and \"a\"-\"e\" indicating a column swap\n    \"\"\"",
    "sol_bodies": [
      "    i = [sum(row) for row in matrix].index(1)\n    j = matrix[i].index(1)\n    ans = \"\"\n    while i > 2:\n        ans += str(i - 1)\n        i -= 1\n    while i < 2:\n        ans += str(i)\n        i += 1\n    while j > 2:\n        ans += \"abcde\"[j - 1]\n        j -= 1\n    while j < 2:\n        ans += \"abcde\"[j]\n        j += 1\n    return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 263 A](https://codeforces.com/problemset/problem/263/A)",
    "weight": 1.0
  },
  {
    "name": "SortPlusPlus:0",
    "sat": "def sat(s: str, inp=\"1+1+3+1+3+2+2+1+3+1+2\"):\n    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))",
    "ans_type": "str",
    "sol_header": "def sol(inp=\"1+1+3+1+3+2+2+1+3+1+2\"):",
    "sol_docstring": "    \"\"\"Sort numbers in a sum of digits, e.g., 1+3+2+1 -> 1+1+2+3\"\"\"",
    "sol_bodies": [
      "    return \"+\".join(sorted(inp.split(\"+\")))"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 339 A](https://codeforces.com/problemset/problem/339/A)",
    "weight": 1.0
  },
  {
    "name": "CapitalizeFirstLetter:0",
    "sat": "def sat(s: str, word=\"konjac\"):\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True",
    "ans_type": "str",
    "sol_header": "def sol(word=\"konjac\"):",
    "sol_docstring": "    \"\"\"Capitalize the first letter of word\"\"\"",
    "sol_bodies": [
      "    return word[0].upper() + word[1:]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 281 A](https://codeforces.com/problemset/problem/281/A)",
    "weight": 1.0
  },
  {
    "name": "LongestSubsetString:0",
    "sat": "def sat(t: str, s=\"abbbcabbac\", target=7):\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))",
    "ans_type": "str",
    "sol_header": "def sol(s=\"abbbcabbac\", target=7):",
    "sol_docstring": "    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"",
    "sol_bodies": [
      "    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 266 A](https://codeforces.com/problemset/problem/266/A)",
    "weight": 1.0
  },
  {
    "name": "FindHomogeneousSubstring:0",
    "sat": "def sat(n: int, s=\"0000101111111000010\", k=5):\n    return s[n:n + k] == s[n] * k",
    "ans_type": "int",
    "sol_header": "def sol(s=\"0000101111111000010\", k=5):",
    "sol_docstring": "    \"\"\"\n    You are given a string consisting of 0's and 1's. Find an index after which the subsequent k characters are\n    all 0's or all 1's.\n\n    Sample Input:\n    s = 0000111111100000, k = 5\n\n    Sample Output:\n    4\n    (or 5 or 6 or 11)\n    \"\"\"",
    "sol_bodies": [
      "    return s.index(\"0\" * k if \"0\" * k in s else \"1\" * k)",
      "    import re\n    return re.search(r\"([01])\\1{\" + str(k - 1) + \"}\", s).span()[0]",
      "    if \"0\" * k in s:\n        return s.index(\"0\" * k)\n    else:\n        return s.index(\"1\" * k)",
      "    try:\n        return s.index(\"0\" * k)\n    except:\n        return s.index(\"1\" * k)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 96 A](https://codeforces.com/problemset/problem/96/A)",
    "weight": 1.0
  },
  {
    "name": "Triple0:0",
    "sat": "def sat(delta: List[int], nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))",
    "ans_type": "List[int]",
    "sol_header": "def sol(nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):",
    "sol_docstring": "    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"",
    "sol_bodies": [
      "    return [-sum(vec[i] for vec in nums) for i in range(3)]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/69/A)",
    "weight": 1.0
  },
  {
    "name": "TotalDifference:0",
    "sat": "def sat(n: int, a=17, b=100, c=20):\n    return n + a == sum([b * i for i in range(c)])",
    "ans_type": "int",
    "sol_header": "def sol(a=17, b=100, c=20):",
    "sol_docstring": "    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"",
    "sol_bodies": [
      "    return -a + sum([b * i for i in range(c)])"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 546 A](https://codeforces.com/problemset/problem/546/A)",
    "weight": 1.0
  },
  {
    "name": "TripleDouble:0",
    "sat": "def sat(n: int, v=17, w=100):\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w",
    "ans_type": "int",
    "sol_header": "def sol(v=17, w=100):",
    "sol_docstring": "    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"",
    "sol_bodies": [
      "    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 791 A](https://codeforces.com/problemset/problem/791/A)",
    "weight": 1.0
  },
  {
    "name": "RepeatDec:0",
    "sat": "def sat(res: int, m=1234578987654321, n=4):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m",
    "ans_type": "int",
    "sol_header": "def sol(m=1234578987654321, n=4):",
    "sol_docstring": "    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"",
    "sol_bodies": [
      "    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 977 A](https://codeforces.com/problemset/problem/977/A)",
    "weight": 1.0
  },
  {
    "name": "ShortestDecDelta:0",
    "sat": "def sat(li: List[int], n=149432, upper=14943):\n    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=149432, upper=14943):",
    "sol_docstring": "    \"\"\"\n    Find a the shortest sequence of integers going from 1 to n where each difference is at most 10.\n    Do not include 1 or n in the sequence.\n    \"\"\"",
    "sol_bodies": [
      "    m = 1\n    ans = []\n    while True:\n        m = min(n, m + 10)\n        if m >= n:\n            return ans\n        ans.append(m)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 617 A](https://codeforces.com/problemset/problem/617/A)",
    "weight": 1.0
  },
  {
    "name": "MaxDelta:0",
    "sat": "def sat(n: int, pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success",
    "ans_type": "int",
    "sol_header": "def sol(pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):",
    "sol_docstring": "    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"",
    "sol_bodies": [
      "    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 116 A](https://codeforces.com/problemset/problem/116/A)",
    "weight": 1.0
  },
  {
    "name": "CommonCase:0",
    "sat": "def sat(s_case: str, s=\"CanYouTellIfItHASmoreCAPITALS\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())",
    "ans_type": "str",
    "sol_header": "def sol(s=\"CanYouTellIfItHASmoreCAPITALS\"):",
    "sol_docstring": "    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"",
    "sol_bodies": [
      "    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 59 A](https://codeforces.com/problemset/problem/59/A)\n\nThis is a trivial puzzle, especially if the AI realizes that it can can just copy the solution from\nthe problem",
    "weight": 1.0
  },
  {
    "name": "Sssuubbstriiingg:0",
    "sat": "def sat(inds: List[int], string=\"Sssuubbstrissiingg\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"substring\"",
    "ans_type": "List[int]",
    "sol_header": "def sol(string=\"Sssuubbstrissiingg\"):",
    "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"substring\"\"\"",
    "sol_bodies": [
      "    target = \"substring\"\n    j = 0\n    ans = []\n    for i in range(len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)",
    "weight": 1.0
  },
  {
    "name": "Sstriiinggssuubb:0",
    "sat": "def sat(inds: List[int], string=\"enlightenment\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"",
    "ans_type": "List[int]",
    "sol_header": "def sol(string=\"enlightenment\"):",
    "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"",
    "sol_bodies": [
      "    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)",
    "weight": 1.0
  },
  {
    "name": "Moving0s:0",
    "sat": "def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):\n    s = seq[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(seq) - 1):\n            if (s[i], s[i + 1]) == (0, 1):\n                (s[i], s[i + 1]) = (1, 0)\n    return s == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):",
    "sol_docstring": "    \"\"\"\n    Find a sequence of 0's and 1's so that, after n_steps of swapping each adjacent (0, 1), the target sequence\n    is achieved.\n    \"\"\"",
    "sol_bodies": [
      "    s = target[:]  # copy\n    for step in range(n_steps):\n        for i in range(len(target) - 2, -1, -1):\n            if (s[i], s[i + 1]) == (1, 0):\n                (s[i], s[i + 1]) = (0, 1)\n    return s"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 266 B](https://codeforces.com/problemset/problem/266/B)",
    "weight": 1.0
  },
  {
    "name": "Factor47:0",
    "sat": "def sat(d: int, n=6002685529):\n    return n % d == 0 and all(i in \"47\" for i in str(d))",
    "ans_type": "int",
    "sol_header": "def sol(n=6002685529):",
    "sol_docstring": "    \"\"\"Find a integer factor of n whose decimal representation consists only of 7's and 4's.\"\"\"",
    "sol_bodies": [
      "    def helper(so_far, k):\n        if k > 0:\n            return helper(so_far * 10 + 4, k - 1) or helper(so_far * 10 + 7, k - 1)\n        return (n % so_far == 0) and so_far\n\n    for length in range(1, len(str(n)) // 2 + 2):\n        ans = helper(0, length)\n        if ans:\n            return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 122 A](https://codeforces.com/problemset/problem/122/A)",
    "weight": 1.0
  },
  {
    "name": "Count47:0",
    "sat": "def sat(d: int, n=123456789):\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))",
    "ans_type": "int",
    "sol_header": "def sol(n=123456789):",
    "sol_docstring": "    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"",
    "sol_bodies": [
      "    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 110 A](https://codeforces.com/problemset/problem/110/A)",
    "weight": 1.0
  },
  {
    "name": "MaybeReversed:0",
    "sat": "def sat(s: str, target=\"reverse me\", reverse=True):\n    return (s[::-1] == target) == reverse",
    "ans_type": "str",
    "sol_header": "def sol(target=\"reverse me\", reverse=True):",
    "sol_docstring": "    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"",
    "sol_bodies": [
      "    return target[::-1] if reverse else target + \"x\""
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 41 A](https://codeforces.com/problemset/problem/41/A)",
    "weight": 1.0
  },
  {
    "name": "MinBigger:0",
    "sat": "def sat(taken: List[int], val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):\n    advantage = 0\n    assert len(taken) == len(val_counts) and sum(taken) <= upper\n    for i, (val, count) in zip(taken, val_counts):\n        assert 0 <= i <= count\n        advantage += val * i - val * count / 2\n    return advantage > 0",
    "ans_type": "List[int]",
    "sol_header": "def sol(val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):",
    "sol_docstring": "    \"\"\"\n    The list of numbers val_counts represents multiple copies of integers, e.g.,\n    val_counts=[[3, 2], [4, 6]] corresponds to 3, 3, 4, 4, 4, 4, 4, 4\n    For each number, decide how many to take so that the total number taken is <= upper and the sum of those\n    taken exceeds half the total sum.\n    \"\"\"",
    "sol_bodies": [
      "    n = len(val_counts)\n    pi = sorted(range(n), key=lambda i: val_counts[i][0])\n    needed = sum(a * b for a, b in val_counts) / 2 + 0.1\n    ans = [0] * n\n    while needed > 0:\n        while val_counts[pi[-1]][1] == ans[pi[-1]]:\n            pi.pop()\n        i = pi[-1]\n        ans[i] += 1\n        needed -= val_counts[i][0]\n    return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 160 A](https://codeforces.com/problemset/problem/160/A)",
    "weight": 1.0
  },
  {
    "name": "Dada:0",
    "sat": "def sat(s: str, a=5129, d=17):\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d",
    "ans_type": "str",
    "sol_header": "def sol(a=5129, d=17):",
    "sol_docstring": "    \"\"\"Find a string with a given number of a's and d's\"\"\"",
    "sol_bodies": [
      "    return \"a\" * a + \"d\" * d"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 734 A](https://codeforces.com/problemset/problem/734/A)",
    "weight": 1.0
  },
  {
    "name": "DistinctDigits:0",
    "sat": "def sat(nums: List[int], a=100, b=1000, count=648):\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count",
    "ans_type": "List[int]",
    "sol_header": "def sol(a=100, b=1000, count=648):",
    "sol_docstring": "    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"",
    "sol_bodies": [
      "    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 271 A](https://codeforces.com/problemset/problem/271/A)",
    "weight": 1.0
  },
  {
    "name": "EasySum:0",
    "sat": "def sat(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):\n    return tot == sum(1 if i < thresh else 2 for i in nums)",
    "ans_type": "int",
    "sol_header": "def sol(nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):",
    "sol_docstring": "    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"",
    "sol_bodies": [
      "    return sum(1 if i < thresh else 2 for i in nums)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 677 A](https://codeforces.com/problemset/problem/677/A)",
    "weight": 1.0
  },
  {
    "name": "GimmeChars:0",
    "sat": "def sat(s: str, chars=['o', 'h', 'e', 'l', ' ', 'w', '!', 'r', 'd']):\n    for c in chars:\n        if c not in s:\n            return False\n    return True",
    "ans_type": "str",
    "sol_header": "def sol(chars=['o', 'h', 'e', 'l', ' ', 'w', '!', 'r', 'd']):",
    "sol_docstring": "    \"\"\"Find a string with certain characters\"\"\"",
    "sol_bodies": [],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 133 A](https://codeforces.com/problemset/problem/133/A), easy",
    "weight": 1.0
  },
  {
    "name": "HalfPairs:0",
    "sat": "def sat(ans: List[List[int]], target=17):\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(target=17):",
    "sol_docstring": "    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"",
    "sol_bodies": [
      "    return [[0, 2]] * target"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 467 A](https://codeforces.com/problemset/problem/467/A)",
    "weight": 1.0
  },
  {
    "name": "InvertIndices:0",
    "sat": "def sat(indexes: List[int], target=[1, 3, 4, 2, 5, 6, 7, 13, 12, 11, 9, 10, 8]):\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=[1, 3, 4, 2, 5, 6, 7, 13, 12, 11, 9, 10, 8]):",
    "sol_docstring": "    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"",
    "sol_bodies": [],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 136 A](https://codeforces.com/problemset/problem/136/A)",
    "weight": 1.0
  },
  {
    "name": "FivePowers:0",
    "sat": "def sat(s: str, n=7012):\n    return int(str(5 ** n)[:-2] + s) == 5 ** n",
    "ans_type": "str",
    "sol_header": "def sol(n=7012):",
    "sol_docstring": "    \"\"\"What are the last two digits of 5^n?\"\"\"",
    "sol_bodies": [
      "    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/630/A)",
    "weight": 1.0
  },
  {
    "name": "CombinationLock:0",
    "sat": "def sat(states: List[str], start=\"424\", combo=\"778\", target_len=12):\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len",
    "ans_type": "List[str]",
    "sol_header": "def sol(start=\"424\", combo=\"778\", target_len=12):",
    "sol_docstring": "    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"",
    "sol_bodies": [
      "    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)",
    "weight": 1.0
  },
  {
    "name": "CombinationLockObfuscated:0",
    "sat": "def sat(states: List[str], start=\"424\", combo=\"778\", target_len=12):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))",
    "ans_type": "List[str]",
    "sol_header": "def sol(start=\"424\", combo=\"778\", target_len=12):",
    "sol_docstring": "    \"\"\"Figure out what this does only from the code\"\"\"",
    "sol_bodies": [
      "    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)\nThis an obfuscated version of CombinationLock above, can the AI figure out what is being asked or that\nit is the same puzzle?",
    "weight": 1.0
  },
  {
    "name": "InvertPermutation:0",
    "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hello are you there?\"):\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target",
    "ans_type": "str",
    "sol_header": "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"hello are you there?\"):",
    "sol_docstring": "    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"",
    "sol_bodies": [
      "    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 474 A](https://codeforces.com/problemset/problem/474/A)",
    "weight": 1.0
  },
  {
    "name": "SameDifferent:0",
    "sat": "def sat(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):",
    "sol_docstring": "    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"",
    "sol_bodies": [
      "    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 1335 C](https://codeforces.com/problemset/problem/1335/C)",
    "weight": 1.0
  },
  {
    "name": "OnesAndTwos:0",
    "sat": "def sat(seq: List[int], n=10000, length=5017):\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=10000, length=5017):",
    "sol_docstring": "    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"",
    "sol_bodies": [
      "    return [2] * (n - length) + [1] * (2 * length - n)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 476 A](https://codeforces.com/problemset/problem/476/A)",
    "weight": 1.0
  },
  {
    "name": "MinConsecutiveSum:0",
    "sat": "def sat(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper",
    "ans_type": "int",
    "sol_header": "def sol(k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):",
    "sol_docstring": "    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"",
    "sol_bodies": [
      "    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)",
    "weight": 1.0
  },
  {
    "name": "MaxConsecutiveSum:0",
    "sat": "def sat(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower",
    "ans_type": "int",
    "sol_header": "def sol(k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):",
    "sol_docstring": "    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"",
    "sol_bodies": [
      "    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)",
    "weight": 1.0
  },
  {
    "name": "MaxConsecutiveProduct:0",
    "sat": "def sat(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower",
    "ans_type": "int",
    "sol_header": "def sol(k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):",
    "sol_docstring": "    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"",
    "sol_bodies": [
      "    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)",
    "weight": 1.0
  },
  {
    "name": "DistinctOddSum:0",
    "sat": "def sat(nums: List[int], tot=12345, n=5):\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)",
    "ans_type": "List[int]",
    "sol_header": "def sol(tot=12345, n=5):",
    "sol_docstring": "    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"",
    "sol_bodies": [
      "    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 1327 A](https://codeforces.com/problemset/problem/1327/A)",
    "weight": 1.0
  },
  {
    "name": "MinRotations:0",
    "sat": "def sat(rotations: List[int], target=\"wonderful\", upper=69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=\"wonderful\", upper=69):",
    "sol_docstring": "    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"",
    "sol_bodies": [
      "    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 731 A](https://codeforces.com/problemset/problem/731/A)",
    "weight": 1.0
  },
  {
    "name": "BillSums:0",
    "sat": "def sat(bills: List[int], denominations=[1, 25, 35, 84], n=980, max_len=14):\n    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len",
    "ans_type": "List[int]",
    "sol_header": "def sol(denominations=[1, 25, 35, 84], n=980, max_len=14):",
    "sol_docstring": "    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"",
    "sol_bodies": [
      "    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]"
    ],
    "module": "codeforces.py",
    "notes": "Inspired by [Codeforces Problem 996 A](https://codeforces.com/problemset/problem/996/A)\n\nWe make it much harder when the denominations are non-American so the greedy algorithm doesn't work.",
    "weight": 1.0
  },
  {
    "name": "BoxVolume:0",
    "sat": "def sat(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim",
    "ans_type": "List[int]",
    "sol_header": "def sol(options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):",
    "sol_docstring": "    \"\"\"\n    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,\n     where each side length is in options\n    \"\"\"",
    "sol_bodies": [
      "    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]"
    ],
    "module": "codeforces.py",
    "notes": "(Also) inspired by [Codeforces Problem 996 A](https://codeforces.com/problemset/problem/996/A)\n\nWe make it much much harder by making it a multiplication problem where the greedy algorithm doesn't work.",
    "weight": 1.0
  },
  {
    "name": "QuadraticRoot:0",
    "sat": "def sat(x: float, coeffs=[2.5, 1.3, -0.5]):\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6",
    "ans_type": "float",
    "sol_header": "def sol(coeffs=[2.5, 1.3, -0.5]):",
    "sol_docstring": "    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"",
    "sol_bodies": [
      "    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans",
      "    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"
    ],
    "module": "algebra.py",
    "notes": "See [quadratic equations](https://en.wikipedia.org/wiki/Quadratic_formula)",
    "weight": 1.0
  },
  {
    "name": "AllQuadraticRoots:0",
    "sat": "def sat(roots: List[float], coeffs=[1.3, -0.5]):\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6",
    "ans_type": "List[float]",
    "sol_header": "def sol(coeffs=[1.3, -0.5]):",
    "sol_docstring": "    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"",
    "sol_bodies": [
      "    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"
    ],
    "module": "algebra.py",
    "notes": "See [quadratic equations](https://en.wikipedia.org/wiki/Quadratic_formula).",
    "weight": 1.0
  },
  {
    "name": "CubicRoot:0",
    "sat": "def sat(x: float, coeffs=[2.0, 1.0, 0.0, 8.0]):\n    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6",
    "ans_type": "float",
    "sol_header": "def sol(coeffs=[2.0, 1.0, 0.0, 8.0]):",
    "sol_docstring": "    \"\"\"\n    Find any (real) solution to: a x^3 + b x^2 + c x + d where coeffs = [a, b, c, d]\n    For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6, sat(x = 1., coeffs = [-6., 11., -6.]) is True.\n    \"\"\"",
    "sol_bodies": [
      "    a2, a1, a0 = [c / coeffs[0] for c in coeffs[1:]]\n    p = (3 * a1 - a2 ** 2) / 3\n    q = (9 * a1 * a2 - 27 * a0 - 2 * a2 ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        c = cube ** (1 / 3)\n        for w in [c, c * omega, c * omega.conjugate()]:\n            if w != 0:\n                x = complex(w - p / (3 * w) - a2 / 3).real\n                if abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6:\n                    return x"
    ],
    "module": "algebra.py",
    "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).",
    "weight": 1.0
  },
  {
    "name": "AllCubicRoots:0",
    "sat": "def sat(roots: List[float], coeffs=[1.0, -2.0, -1.0]):\n    r1, r2, r3 = roots\n    a, b, c = coeffs\n    return abs(r1 + r2 + r3 + a) + abs(r1 * r2 + r1 * r3 + r2 * r3 - b) + abs(r1 * r2 * r3 + c) < 1e-6",
    "ans_type": "List[float]",
    "sol_header": "def sol(coeffs=[1.0, -2.0, -1.0]):",
    "sol_docstring": "    \"\"\"Find all 3 distinct real roots of x^3 + a x^2 + b x + c, i.e., factor into (x-r1)(x-r2)(x-r3).\n    coeffs = [a, b, c]. For example, since (x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x - 6,\n    sat(roots = [1., 2., 3.], coeffs = [-6., 11., -6.]) is True.\n    \"\"\"",
    "sol_bodies": [
      "    a, b, c = coeffs\n    p = (3 * b - a ** 2) / 3\n    q = (9 * b * a - 27 * c - 2 * a ** 3) / 27\n    delta = (q ** 2 + 4 * p ** 3 / 27) ** 0.5\n    omega = (-(-1) ** (1 / 3))\n    ans = []\n    for cube in [(q + delta) / 2, (q - delta) / 2]:\n        v = cube ** (1 / 3)\n        for w in [v, v * omega, v * omega.conjugate()]:\n            if w != 0.0:\n                x = complex(w - p / (3 * w) - a / 3).real\n                if abs(x ** 3 + a * x ** 2 + b * x + c) < 1e-4:\n                    if not ans or min(abs(z - x) for z in ans) > 1e-6:\n                        ans.append(x)\n    if len(ans) == 3:\n        return ans"
    ],
    "module": "algebra.py",
    "notes": "See [cubic equation](https://en.wikipedia.org/wiki/Cubic_formula).",
    "weight": 1.0
  },
  {
    "name": "SumOfDigits:0",
    "sat": "def sat(x: str, s=679):\n    return s == sum([int(d) for d in x])",
    "ans_type": "str",
    "sol_header": "def sol(s=679):",
    "sol_docstring": "    \"\"\"Find a number that its digits sum to a specific value.\"\"\"",
    "sol_bodies": [
      "    return int(s / 9) * '9' + str(s % 9)"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "FloatWithDecimalValue:0",
    "sat": "def sat(z: float, v=9, d=0.0001):\n    return int(z * 1 / d % 10) == v",
    "ans_type": "float",
    "sol_header": "def sol(v=9, d=0.0001):",
    "sol_docstring": "    \"\"\"Create a float with a specific decimal.\"\"\"",
    "sol_bodies": [
      "    return v * d"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "ArithmeticSequence:0",
    "sat": "def sat(x: List[int], a=7, s=5, e=200):\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])",
    "ans_type": "List[int]",
    "sol_header": "def sol(a=7, s=5, e=200):",
    "sol_docstring": "    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"",
    "sol_bodies": [
      "    return list(range(a, e + 1, s))"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "GeometricSequence:0",
    "sat": "def sat(x: List[int], a=8, r=2, l=50):\n    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])",
    "ans_type": "List[int]",
    "sol_header": "def sol(a=8, r=2, l=50):",
    "sol_docstring": "    \"\"\"Create a list that is a subrange of an gemoetric sequence.\"\"\"",
    "sol_bodies": [
      "    return [a * r ** i for i in range(l)]"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "LineIntersection:0",
    "sat": "def sat(e: List[int], a=2, b=-1, c=1, d=2021):\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5",
    "ans_type": "List[int]",
    "sol_header": "def sol(a=2, b=-1, c=1, d=2021):",
    "sol_docstring": "    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"",
    "sol_bodies": [
      "    return [d - b, a - c]"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "IfProblem:0",
    "sat": "def sat(x: int, a=324554, b=1345345):\n    if a < 50:\n        return x + a == b\n    else:\n        return x - 2 * a == b",
    "ans_type": "int",
    "sol_header": "def sol(a=324554, b=1345345):",
    "sol_docstring": "    \"\"\"Satisfy a simple if statement\"\"\"",
    "sol_bodies": [
      "    if a < 50:\n        return b - a\n    else:\n        return b + 2 * a"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "IfProblemWithAnd:0",
    "sat": "def sat(x: int, a=9384594, b=1343663):\n    if x > 0 and a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "ans_type": "int",
    "sol_header": "def sol(a=9384594, b=1343663):",
    "sol_docstring": "    \"\"\"Satisfy a simple if statement with an and clause\"\"\"",
    "sol_bodies": [
      "    if a > 50 and b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "IfProblemWithOr:0",
    "sat": "def sat(x: int, a=253532, b=1230200):\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b",
    "ans_type": "int",
    "sol_header": "def sol(a=253532, b=1230200):",
    "sol_docstring": "    \"\"\"Satisfy a simple if statement with an or clause\"\"\"",
    "sol_bodies": [
      "    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "IfCases:0",
    "sat": "def sat(x: int, a=4, b=54368639):\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b",
    "ans_type": "int",
    "sol_header": "def sol(a=4, b=54368639):",
    "sol_docstring": "    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"",
    "sol_bodies": [
      "    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "ListPosSum:0",
    "sat": "def sat(x: List[int], n=5, s=19):\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=5, s=19):",
    "sol_docstring": "    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"",
    "sol_bodies": [
      "    x = [1] * n\n    x[0] = s - n + 1\n    return x"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "ListDistinctSum:0",
    "sat": "def sat(x: List[int], n=4, s=2021):\n    return len(x) == n and sum(x) == s and len(set(x)) == n",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=4, s=2021):",
    "sol_docstring": "    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"",
    "sol_bodies": [
      "    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "ConcatStrings:0",
    "sat": "def sat(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])",
    "ans_type": "str",
    "sol_header": "def sol(s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):",
    "sol_docstring": "    \"\"\"Concatenate the list of characters in s\"\"\"",
    "sol_bodies": [
      "    return ''.join([s[i] for i in range(n)])"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "SublistSum:0",
    "sat": "def sat(x: List[int], t=677, a=43, e=125, s=10):\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])",
    "ans_type": "List[int]",
    "sol_header": "def sol(t=677, a=43, e=125, s=10):",
    "sol_docstring": "    \"\"\"Sum values of sublist by range specifications\"\"\"",
    "sol_bodies": [
      "    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "CumulativeSum:0",
    "sat": "def sat(x: List[int], t=50, n=10):\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n",
    "ans_type": "List[int]",
    "sol_header": "def sol(t=50, n=10):",
    "sol_docstring": "    \"\"\"Find how many values have cumulative sum less than target\"\"\"",
    "sol_bodies": [
      "    return [1] * n + [t]"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "BasicStrCounts:0",
    "sat": "def sat(s: str, s1=\"a\", s2=\"b\", count1=50, count2=30):\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]",
    "ans_type": "str",
    "sol_header": "def sol(s1=\"a\", s2=\"b\", count1=50, count2=30):",
    "sol_docstring": "    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"",
    "sol_bodies": [
      "    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "ZipStr:0",
    "sat": "def sat(s: str, substrings=['foo', 'bar', 'baz', 'oddball']):\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))",
    "ans_type": "str",
    "sol_header": "def sol(substrings=['foo', 'bar', 'baz', 'oddball']):",
    "sol_docstring": "    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"",
    "sol_bodies": [
      "    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "ReverseCat:0",
    "sat": "def sat(s: str, substrings=['foo', 'bar', 'baz']):\n    return all(sub in s and sub[::-1] in s for sub in substrings)",
    "ans_type": "str",
    "sol_header": "def sol(substrings=['foo', 'bar', 'baz']):",
    "sol_docstring": "    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"",
    "sol_bodies": [
      "    return \"\".join(substrings + [s[::-1] for s in substrings])"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "EngineerNumbers:0",
    "sat": "def sat(ls: List[str], n=100, a=\"bar\", b=\"foo\"):\n    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)",
    "ans_type": "List[str]",
    "sol_header": "def sol(n=100, a=\"bar\", b=\"foo\"):",
    "sol_docstring": "    \"\"\"\n    Find a list of n strings, in alphabetical order, starting with a and ending with b.\n    \"\"\"",
    "sol_bodies": [
      "    return sorted([a] + [a + chr(0) + str(i) for i in range(n - 2)] + [b])"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "PenultimateString:0",
    "sat": "def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s in strings and sum(t > s for t in strings) == 1",
    "ans_type": "str",
    "sol_header": "def sol(strings=['cat', 'dog', 'bird', 'fly', 'moose']):",
    "sol_docstring": "    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"",
    "sol_bodies": [
      "    return sorted(strings)[-2]"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "PenultimateRevString:0",
    "sat": "def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1",
    "ans_type": "str",
    "sol_header": "def sol(strings=['cat', 'dog', 'bird', 'fly', 'moose']):",
    "sol_docstring": "    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"",
    "sol_bodies": [
      "    return sorted(strings)[1][::-1]"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "CenteredString:0",
    "sat": "def sat(s: str, target=\"foobarbazwow\", length=6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s",
    "ans_type": "str",
    "sol_header": "def sol(target=\"foobarbazwow\", length=6):",
    "sol_docstring": "    \"\"\"Find a substring of the given length centered within the target string.\"\"\"",
    "sol_bodies": [
      "    return target[(len(target) - length) // 2:(len(target) + length) // 2]"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "SubstrCount:0",
    "sat": "def sat(substring: str, string=\"moooboooofasd\", count=2):\n    return string.count(substring) == count",
    "ans_type": "str",
    "sol_header": "def sol(string=\"moooboooofasd\", count=2):",
    "sol_docstring": "    \"\"\"Find a substring with a certain count in a given string\"\"\"",
    "sol_bodies": [
      "    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "CompleteParens:0",
    "sat": "def sat(t: str, s=\"))(Add)some))parens()to()(balance(()(()(me!)((((\"):\n    for i in range(len(t) + 1):\n        depth = t[:i].count(\"(\") - t[:i].count(\")\")\n        assert depth >= 0\n    return depth == 0 and s in t",
    "ans_type": "str",
    "sol_header": "def sol(s=\"))(Add)some))parens()to()(balance(()(()(me!)((((\"):",
    "sol_docstring": "    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"",
    "sol_bodies": [
      "    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")"
    ],
    "module": "basic.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "EightQueensOrFewer:0",
    "sat": "def sat(squares: List[List[int]], m=8, n=8):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=8, n=8):",
    "sol_docstring": "    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"",
    "sol_bodies": [
      "    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"
    ],
    "module": "chess.py",
    "notes": "Eight (or fewer) Queens Puzzle\n\nSee Wikipedia entry on\n[Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nSee the MoreQueens puzzle below for another (longer but clearer) equivalent definition of sat\n\nHint: a brute force approach works on this puzzle.",
    "weight": 1.0
  },
  {
    "name": "MoreQueens:0",
    "sat": "def sat(squares: List[List[int]], m=9, n=9):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares), \"queen off board\"\n    assert len(squares) == k, \"Wrong number of queens\"\n    assert len({i for i, j in squares}) == k, \"Queens on same row\"\n    assert len({j for i, j in squares}) == k, \"Queens on same file\"\n    assert len({i + j for i, j in squares}) == k, \"Queens on same SE diagonal\"\n    assert len({i - j for i, j in squares}) == k, \"Queens on same NE diagonal\"\n    return True",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=9, n=9):",
    "sol_docstring": "    \"\"\"\n    Position min(m, n) > 8 queens on an m x n chess board so that no pair is attacking each other.\n    \"\"\"",
    "sol_bodies": [
      "    t = min(m, n)\n    ans = []\n    if t % 2 == 1:  # odd k, put a queen in the lower right corner (and decrement k)\n        ans.append([t - 1, t - 1])\n        t -= 1\n    if t % 6 == 2:  # do something special for 8x8, 14x14 etc:\n        ans += [[i, (2 * i + t // 2 - 1) % t] for i in range(t // 2)]\n        ans += [[i + t // 2, (2 * i - t // 2 + 2) % t] for i in range(t // 2)]\n    else:\n        ans += [[i, 2 * i + 1] for i in range(t // 2)]\n        ans += [[i + t // 2, 2 * i] for i in range(t // 2)]\n    return ans"
    ],
    "module": "chess.py",
    "notes": "See Wikipedia entry on [Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nA brute force approach will not work on many of these problems.",
    "weight": 1.0
  },
  {
    "name": "KnightsTour:0",
    "sat": "def sat(tour: List[List[int]], m=8, n=8):\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=8, n=8):",
    "sol_docstring": "    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"",
    "sol_bodies": [
      "    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"
    ],
    "module": "chess.py",
    "notes": "See Wikipedia entry on [Knight's tour](https://en.wikipedia.org/w/index.php?title=Knight%27s_tour)",
    "weight": 1.0
  },
  {
    "name": "UncrossedKnightsPath:0",
    "sat": "def sat(path: List[List[int]], m=8, n=8, target=35):\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=8, n=8, target=35):",
    "sol_docstring": "    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"",
    "sol_bodies": [],
    "module": "chess.py",
    "notes": "Uncrossed Knights Path (known solvable, but no solution given)\n\nThe goal of these problems is to match the nxn_records from [http://ukt.alex-black.ru/](http://ukt.alex-black.ru/)\n(accessed 2020-11-29).\n\nA more precise description is in this\n[Wikipedia article](https://en.wikipedia.org/w/index.php?title=Longest_uncrossed_knight%27s_path).",
    "weight": 1.0
  },
  {
    "name": "UNSOLVED_UncrossedKnightsPath:0",
    "sat": "def sat(path: List[List[int]], m=10, n=10, target=62):\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(m=10, n=10, target=62):",
    "sol_docstring": "    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"",
    "sol_bodies": [],
    "module": "chess.py",
    "notes": "Uncrossed Knights Path (open problem, unsolved)\n\nSimilar to above, but the goal of these problems is to *beat* the nxn_records from\n[http://ukt.alex-black.ru/](http://ukt.alex-black.ru/)\n(accessed 2020-11-29).\n\nA more precise description is in this\n[Wikipedia article](https://en.wikipedia.org/w/index.php?title=Longest_uncrossed_knight%27s_path).",
    "weight": 1.0
  },
  {
    "name": "LZW:0",
    "sat": "def sat(seq: List[int], compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):\n    index = [chr(i) for i in range(256)]\n    pieces = [\"\"]\n    for i in seq:\n        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])\n        index.append(pieces[-2] + pieces[-1][0])\n    return \"\".join(pieces) == text and len(seq) <= compressed_len",
    "ans_type": "List[int]",
    "sol_header": "def sol(compressed_len=17, text=\"Hellooooooooooooooooooooo world!\"):",
    "sol_docstring": "    \"\"\"\n    Find a (short) compression that decompresses to the given string for the provided implementation of the\n    Lempel-Ziv decompression algorithm from https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n    \"\"\"",
    "sol_bodies": [
      "    # compressed_len is ignored\n    index = {chr(i): i for i in range(256)}\n    seq = []\n    buffer = \"\"\n    for c in text:\n        if buffer + c in index:\n            buffer += c\n            continue\n        seq.append(index[buffer])\n        index[buffer + c] = len(index) + 1\n        buffer = c\n\n    if text != \"\":\n        seq.append(index[buffer])\n\n    return seq"
    ],
    "module": "compression.py",
    "notes": "We have provided a simple version of the *decompression* algorithm of\n[Lempel-Ziv-Welch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\nso the solution is the *compression* algorithm.",
    "weight": 1.0
  },
  {
    "name": "PackingHam:0",
    "sat": "def sat(words: List[str], num=100, bits=100, dist=34):\n    assert len(words) == num and all(len(word) == bits and set(word) <= {\"0\", \"1\"} for word in words)\n    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))",
    "ans_type": "List[str]",
    "sol_header": "def sol(num=100, bits=100, dist=34):",
    "sol_docstring": "    \"\"\"Pack a certain number of binary strings so that they have a minimum hamming distance between each other.\"\"\"",
    "sol_bodies": [
      "    import random  # key insight, use randomness!\n    r = random.Random(0)\n    while True:\n        seqs = [r.getrandbits(bits) for _ in range(num)]\n        if all(bin(seqs[i] ^ seqs[j]).count(\"1\") >= dist for i in range(num) for j in range(i)):\n            return [bin(s)[2:].rjust(bits, '0') for s in seqs]"
    ],
    "module": "compression.py",
    "notes": "This packing problem a [classic problem](https://en.wikipedia.org/wiki/Sphere_packing#Other_spaces)\nin coding theory.",
    "weight": 1.0
  },
  {
    "name": "Oscillators:0",
    "sat": "def sat(init: List[List[int]], period=3):\n    target = {x + y * 1j for x, y in init}  # complex numbers encode live cells\n\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    live = target\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        if live == target:\n            return t + 1 == period",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(period=3):",
    "sol_docstring": "    \"\"\"\n    Find a pattern in Conway's Game of Life https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life that repeats\n    with a certain period https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life\n    \"\"\"",
    "sol_bodies": [
      "    # # generate random patterns, slow solution\n    # def viz(live):\n    #     if not live:\n    #         return\n    #     a, b = min(z.real for z in live), min(z.imag for z in live)\n    #     live = {z - (a + b * 1j) for z in live}\n    #     m, n = int(max(z.real for z in live)) + 1, int(max(z.imag for z in live)) + 1\n    #     for x in range(m):\n    #         print(\"\".join(\"X\" if x + y * 1j in live else \",\" for y in range(n)))\n\n    import random\n    rand = random.Random(1)\n    # print(f\"Looking for {period}:\")\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    completes = [[x + y * 1j for x in range(n) for y in range(n)] for n in range(30)]\n\n    for _attempt in range(10 ** 5):\n        n = rand.randrange(3, 10)\n        m = rand.randrange(3, n * n)\n        live = set(rand.sample(completes[n], m))\n        if rand.randrange(2):\n            live.update([-z for z in live])\n        if rand.randrange(2):\n            live.update([z.conjugate() for z in live])\n        memory = {}\n        for step in range(period * 10):\n            key = sum((.123 - .99123j) ** z for z in live) * 10 ** 5\n            key = int(key.real), int(key.imag)\n            if key in memory:\n                if memory[key] == step - period:\n                    # print(period)\n                    # viz(live)\n                    return [[int(z.real), int(z.imag)] for z in live]\n                break\n            memory[key] = step\n            visible = {z + d for z in live for d in deltas}\n            live = {z for z in visible if sum(z + d in live for d in deltas) in range(3 - (z in live), 4)}\n\n    return None  # failed"
    ],
    "module": "conways_game_of_life.py",
    "notes": "Oscillators (including some unsolved, open problems)\n\nThis problem is *unsolved* for periods 19, 38, and 41.\n\nSee\n[discussion](https://en.wikipedia.org/wiki/Oscillator_%28cellular_automaton%29#:~:text=Game%20of%20Life )\nin Wikipedia article on Cellular Automaton Oscillators.",
    "weight": 1.0
  },
  {
    "name": "ReverseLifeStep:0",
    "sat": "def sat(position: List[List[int]], target=[[1, 3], [1, 4], [2, 5]]):\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(target=[[1, 3], [1, 4], [2, 5]]):",
    "sol_docstring": "    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"",
    "sol_bodies": [
      "    # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"
    ],
    "module": "conways_game_of_life.py",
    "notes": "Unsolvable for \"Garden of Eden\" positions, but we only generate solvable examples",
    "weight": 1.0
  },
  {
    "name": "Spaceship:0",
    "sat": "def sat(init: List[List[int]], period=4):\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(period=4):",
    "sol_docstring": "    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"",
    "sol_bodies": [],
    "module": "conways_game_of_life.py",
    "notes": "Spaceship (including *unsolved*, open problems)\n\nFind a [spaceship](https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29) in\n[Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)\nwith a certain period.\n\nThis is an *unsolved* problem for periods 33, 34.",
    "weight": 1.0
  },
  {
    "name": "Nim:0",
    "sat": "def sat(moves: List[List[int]], initial_state=[5, 9, 3, 11, 18, 25, 1, 2, 4, 1]):\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    state = initial_state[:]  # copy\n    for i, n in moves:\n        assert 0 < n <= state[i], \"Illegal move\"\n        state[i] -= n\n        if set(state) == {0}:\n            return True  # you won!\n        assert any(state), \"You lost!\"\n        bot_move()",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(initial_state=[5, 9, 3, 11, 18, 25, 1, 2, 4, 1]):",
    "sol_docstring": "    \"\"\"\n    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn\n    removing one or more objects from a single non-empty heap. The player who takes the last object wins.\n    - initial_state is list of numbers of objects in each heap\n    - moves is a list of your moves: [heap, number of objects to take]\n    - you play first\n    \"\"\"",
    "sol_bodies": [
      "\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()"
    ],
    "module": "games.py",
    "notes": "Compute optimal play for the classic two-player game [Nim](https://en.wikipedia.org/wiki/Nim)\n\nNim has an elegant theory for optimal play based on the xor of the bits in the heaps.\n\nInstead of writing a program that plays the game interactively (since interaction is not allowed), we require\nthem to determine winning states or beat a certain opponent.",
    "weight": 10.0
  },
  {
    "name": "Mastermind:0",
    "sat": "def sat(transcripts: List[str], max_moves=10):\n    COLORS = \"ABCDEF\"\n\n    def helper(secret: str, transcript=\"\"):\n        if transcript.count(\"\\n\") == max_moves:\n            return False\n        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]\n        if guess == secret:\n            return True\n        assert all(g in COLORS for g in guess)\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return helper(secret, transcript + f\"{guess} {sum(perfect.values())}{almost}\\n\")\n\n    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)",
    "ans_type": "List[str]",
    "sol_header": "def sol(max_moves=10):",
    "sol_docstring": "    \"\"\"\n    Come up with a winning strategy for Mastermind in max_moves moves. Colors are represented by the letters A-F.\n    The solution representation is as follows.\n    A transcript is a string describing the game so far. It consists of rows separated by newlines.\n    Each row has 4 letters A-F followed by a space and then two numbers indicating how many are exactly right\n    and how many are right but in the wrong location. A sample transcript is as follows:\n    AABB 11\n    ABCD 21\n    ABDC\n\n    This is the transcript as the game is in progress. The complete transcript might be:\n    AABB 11\n    ABCD 21\n    ABDC 30\n    ABDE 40\n\n    A winning strategy is described by a list of transcripts to visit. The next guess can be determined from\n    those partial transcripts.\n    \"\"\"",
    "sol_bodies": [
      "    COLORS = \"ABCDEF\"\n\n    transcripts = []\n\n    ALL = [r + s + t + u for r in COLORS for s in COLORS for t in COLORS for u in COLORS]\n\n    def score(secret, guess):\n        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}\n        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)\n        return f\"{sum(perfect.values())}{almost}\"\n\n    def mastermind(transcript=\"AABB\", feasible=ALL):  # mastermind moves\n        transcripts.append(transcript)\n        assert transcript.count(\"\\n\") <= max_moves\n        guess = transcript[-4:]\n        feasibles = {}\n        for secret in feasible:\n            scr = score(secret, guess)\n            if scr not in feasibles:\n                feasibles[scr] = []\n            feasibles[scr].append(secret)\n        for scr, secrets in feasibles.items():\n            if scr != \"40\":\n                guesser(transcript + f\" {scr}\\n\", secrets)\n\n    def guesser(transcript, feasible):  # guesser moves\n        def max_ambiguity(guess):\n            by_score = {}\n            for secret2 in feasible:\n                scr = score(secret2, guess)\n                if scr not in by_score:\n                    by_score[scr] = 0\n                by_score[scr] += 1\n            # for OPTIMAL solution, use return max(by_score.values()) + 0.5 * (guess not in feasible) instead of:\n            return max(by_score.values())\n\n        # for optimal solution use guess = min(ALL, key=max_ambiguity) instead of:\n        guess = min(feasible, key=max_ambiguity)\n\n        mastermind(transcript + guess, feasible)\n\n    mastermind()\n\n    return transcripts"
    ],
    "module": "games.py",
    "notes": "Compute a strategy for winning in [mastermind](https://en.wikipedia.org/wiki/Mastermind_%28board_game%29)\nin a given number of guesses.\n\nInstead of writing a program that plays the game interactively (since interaction is not allowed), we require\nthem to provide a provable winning game tree.",
    "weight": 10.0
  },
  {
    "name": "TicTacToeX:0",
    "sat": "def sat(good_boards: List[str]):\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.\n        x |= 1 << [i for i in range(9) if (x | (1 << i), o) in board_bit_reps][0]\n        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))\n\n    return tie(0, 0)",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Compute a strategy for X (first player) in tic-tac-toe that guarantees a tie. That is a strategy for X that,\n    no matter what the opponent does, X does not lose.\n\n    A board is represented as a 9-char string like an X in the middle would be \"....X....\" and a\n    move is an integer 0-8. The answer is a list of \"good boards\" that X aims for, so no matter what O does there\n    is always good board that X can get to with a single move.\n    \"\"\"",
    "sol_bodies": [
      "    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[o]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and o_move(x | (1 << i), o):\n                good_boards.append(\"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + (i == j)] for j in range(9)))\n                return True\n        return False  # O wins\n\n    def o_move(x, o):  # returns True if x wins or ties, x's turn to move\n        if win[x] or x | o == 511:  # full board\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not x_move(x, o | (1 << i)):\n                return False\n        return True  # O wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"
    ],
    "module": "games.py",
    "notes": "Since we don't have interaction, this problem asks for a full tie-guranteeing strategy.",
    "weight": 1.0
  },
  {
    "name": "TicTacToeO:0",
    "sat": "def sat(good_boards: List[str]):\n    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in \"XO\") for b in good_boards}\n    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]\n\n    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.\n        if o | x != 511:  # complete board\n            o |= 1 << [i for i in range(9) if (x, o | (1 << i)) in board_bit_reps][0]\n        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))\n\n    return all(tie(1 << i, 0) for i in range(9))",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Compute a strategy for O (second player) in tic-tac-toe that guarantees a tie. That is a strategy for O that,\n    no matter what the opponent does, O does not lose.\n\n    A board is represented as a 9-char string like an X in the middle would be \"....X....\" and a\n    move is an integer 0-8. The answer is a list of \"good boards\" that O aims for, so no matter what X does there\n    is always good board that O can get to with a single move.\n    \"\"\"",
    "sol_bodies": [
      "    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]  # 9-bit representation\n\n    good_boards = []\n\n    def x_move(x, o):  # returns True if o wins or ties, x's turn to move\n        if win[o] or x | o == 511:  # full board\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and not o_move(x | (1 << i), o):\n                return False\n        return True  # O wins/ties\n\n    def o_move(x, o):  # returns True if o wins or ties, o's turn to move\n        if win[x]:\n            return False\n        if x | o == 511:\n            return True\n        for i in range(9):\n            if (x | o) & (1 << i) == 0 and x_move(x, o | (1 << i)):\n                good_boards.append(\n                    \"\".join(\".XO\"[((x >> j) & 1) + 2 * ((o >> j) & 1) + 2 * (i == j)] for j in range(9)))\n                return True\n        return False  # X wins\n\n    res = x_move(0, 0)\n    assert res\n\n    return good_boards"
    ],
    "module": "games.py",
    "notes": "Same as above but for 2nd player",
    "weight": 1.0
  },
  {
    "name": "RockPaperScissors:0",
    "sat": "def sat(probs: List[float]):\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6",
    "ans_type": "List[float]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find optimal probabilities for playing Rock-Paper-Scissors zero-sum game, with best worst-case guarantee\"\"\"",
    "sol_bodies": [
      "    return [1 / 3] * 3"
    ],
    "module": "games.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Nash:0",
    "sat": "def sat(strategies: List[List[float]], A=[[1.0, -1.0], [-1.3, 0.8]], B=[[-0.9, 1.1], [0.7, -0.8]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))",
    "ans_type": "List[List[float]]",
    "sol_header": "def sol(A=[[1.0, -1.0], [-1.3, 0.8]], B=[[-0.9, 1.1], [0.7, -0.8]], eps=0.01):",
    "sol_docstring": "    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    eps is the error tolerance\n    \"\"\"",
    "sol_bodies": [
      "    NUM_ATTEMPTS = 10 ** 5\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"
    ],
    "module": "games.py",
    "notes": "Computing a [Nash equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium) for a given\n[bimatrix game](https://en.wikipedia.org/wiki/Bimatrix_game) is known to be\nPPAD-hard in general. However, the challenge is be much easier for an approximate\n[eps-equilibrium](https://en.wikipedia.org/wiki/Epsilon-equilibrium) and of course for small games.",
    "weight": 5.0
  },
  {
    "name": "ZeroSum:0",
    "sat": "def sat(strategies: List[List[float]], A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert all(len(row) == n for row in A), \"inputs are a matrix\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n)))",
    "ans_type": "List[List[float]]",
    "sol_header": "def sol(A=[[0.0, -0.5, 1.0], [0.75, 0.0, -1.0], [-1.0, 0.4, 0.0]], eps=0.01):",
    "sol_docstring": "    \"\"\"\n    Compute minimax optimal strategies for a given zero-sum game up to error tolerance eps.\n    For example, rock paper scissors has\n    A = [[0., -1., 1.], [1., 0., -1.], [-1., 1., 0.]] and strategies = [[0.33, 0.33, 0.34]] * 2\n    \"\"\"",
    "sol_bodies": [
      "    MAX_ITER = 10 ** 4\n    m, n = len(A), len(A[0])\n    a = [0 for _i in range(m)]\n    b = [0 for _j in range(n)]\n\n    for count in range(1, MAX_ITER):\n        i_star = max(range(m), key=lambda i: sum(A[i][j] * b[j] for j in range(n)))\n        j_star = min(range(n), key=lambda j: sum(A[i][j] * a[i] for i in range(m)))\n        a[i_star] += 1\n        b[j_star] += 1\n        p = [x / (count + 1e-6) for x in a]\n        p[-1] = 1 - sum(p[:-1])  # rounding issues\n        q = [x / (count + 1e-6) for x in b]\n        q[-1] = 1 - sum(q[:-1])  # rounding issues\n\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        if (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(A[i][j] * p[i] for i in range(m)) >= v - eps for j in range(n))):\n            return [p, q]"
    ],
    "module": "games.py",
    "notes": "Compute minimax optimal strategies for a given\n[zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game). This problem is known to be equivalent to\nLinear Programming. Note that the provided instances are all quite easy---harder solutions could readily\nbe made by decreasing the accuracy tolerance `eps` at which point the solution we provided would fail and\nmore efficient algorithms would be needed.",
    "weight": 1.0
  },
  {
    "name": "Conway99:0",
    "sat": "def sat(edges: List[List[int]]):\n    # first compute neighbors sets, N:\n    N = {i: {j for j in range(99) if j != i and ([i, j] in edges or [j, i] in edges)} for i in range(99)}\n    return all(len(N[i].intersection(N[j])) == (1 if j in N[i] else 2) for i in range(99) for j in range(i))",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find an undirected graph with 99 vertices, in which each two adjacent vertices have exactly one common\n    neighbor, and in which each two non-adjacent vertices have exactly two common neighbors.\n    \"\"\"",
    "sol_bodies": [],
    "module": "graphs.py",
    "notes": "Conway's 99-graph problem (*unsolved*, open problem)\n\nConway's 99-graph problem is an unsolved problem in graph theory.\nIn Conway's terminology, from [Five $1,000 Problems (Update 2017)](https://oeis.org/A248380/a248380.pdf)\n\"Is there a graph with 99 vertices in which every edge (i.e. pair of joined vertices) belongs to a unique\ntriangle and every nonedge (pair of unjoined vertices) to a unique quadrilateral?\"\n\nSee also this [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Conway%27s_99-graph_problem).",
    "weight": 1.0
  },
  {
    "name": "AnyEdge:0",
    "sat": "def sat(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):\n    return e in edges",
    "ans_type": "List[int]",
    "sol_header": "def sol(edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):",
    "sol_docstring": "    \"\"\"Find any edge in edges.\"\"\"",
    "sol_bodies": [
      "    return edges[0]"
    ],
    "module": "graphs.py",
    "notes": "Trivial [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem.",
    "weight": 1.0
  },
  {
    "name": "AnyTriangle:0",
    "sat": "def sat(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a",
    "ans_type": "List[int]",
    "sol_header": "def sol(edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):",
    "sol_docstring": "    \"\"\"Find any triangle in the given directed graph.\"\"\"",
    "sol_bodies": [
      "    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"
    ],
    "module": "graphs.py",
    "notes": "Easy [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem,\nsee [triangle](https://en.wikipedia.org/w/index.php?title=Triangle_graph)",
    "weight": 1.0
  },
  {
    "name": "PlantedClique:0",
    "sat": "def sat(nodes: List[int], size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    assert len(nodes) == len(set(nodes)) >= size\n    edge_set = {(a, b) for (a, b) in edges}\n    for a in nodes:\n        for b in nodes:\n            assert a == b or (a, b) in edge_set or (b, a) in edge_set\n\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):",
    "sol_docstring": "    \"\"\"Find a clique of the given size in the given undirected graph. It is guaranteed that such a clique exists.\"\"\"",
    "sol_bodies": [
      "    # brute force (finds list in increasing order), but with a tiny bit of speedup\n    if size == 0:\n        return []\n    from collections import defaultdict\n    neighbors = defaultdict(set)\n    n = max(max(e) for e in edges)\n    for (a, b) in edges:\n        if a != b:\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n    pools = [list(range(n + 1))]\n    indices = [-1]\n    while pools:\n        indices[-1] += 1\n        if indices[-1] >= len(pools[-1]) - size + len(pools):  # since list is increasing order\n            indices.pop()\n            pools.pop()\n            continue\n        if len(pools) == size:\n            return [pool[i] for pool, i in zip(pools, indices)]\n        a = (pools[-1])[indices[-1]]\n        pools.append([i for i in pools[-1] if i > a and i in neighbors[a]])\n        indices.append(-1)\n    assert False, f\"No clique of size {size}\""
    ],
    "module": "graphs.py",
    "notes": "Find a [planted clique](https://en.wikipedia.org/w/index.php?title=Planted_clique) of a given size\nin an undirected graph. Finding a polynomial-time algorithm for this problem has been *unsolved* for\nsome time.",
    "weight": 1.0
  },
  {
    "name": "ShortestPath:0",
    "sat": "def sat(path: List[int], weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound",
    "ans_type": "List[int]",
    "sol_header": "def sol(weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):",
    "sol_docstring": "    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"",
    "sol_bodies": [
      "    # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs.py",
    "notes": "Shortest Path, see (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]",
    "weight": 1.0
  },
  {
    "name": "UnweightedShortestPath:0",
    "sat": "def sat(path: List[int], edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound",
    "ans_type": "List[int]",
    "sol_header": "def sol(edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):",
    "sol_docstring": "    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"",
    "sol_bodies": [
      "    # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"
    ],
    "module": "graphs.py",
    "notes": "Unweighted Shortest Path\n\nSee (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]",
    "weight": 1.0
  },
  {
    "name": "AnyPath:0",
    "sat": "def sat(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):",
    "sol_docstring": "    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"",
    "sol_bodies": [
      "    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"
    ],
    "module": "graphs.py",
    "notes": "Any Path",
    "weight": 1.0
  },
  {
    "name": "EvenPath:0",
    "sat": "def sat(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0",
    "ans_type": "List[int]",
    "sol_header": "def sol(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):",
    "sol_docstring": "    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"",
    "sol_bodies": [
      "    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"
    ],
    "module": "graphs.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "OddPath:0",
    "sat": "def sat(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])",
    "ans_type": "List[int]",
    "sol_header": "def sol(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):",
    "sol_docstring": "    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"",
    "sol_bodies": [
      "    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"
    ],
    "module": "graphs.py",
    "notes": "To make it even more different than EvenPath, we changed to go from node 0 to node *1*.",
    "weight": 1.0
  },
  {
    "name": "Zarankiewicz:0",
    "sat": "def sat(edges: List[List[int]], z=20, n=5, t=3):\n    from itertools import combinations\n    edges = {(a, b) for a, b in edges if a in range(n) and b in range(n)}  # convert to a set for efficiency\n    assert len(edges) >= z\n\n    return all(\n        any((a, b) not in edges for a in left for b in right)\n        for left in combinations(range(n), t)\n        for right in combinations(range(n), t)\n    )",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(z=20, n=5, t=3):",
    "sol_docstring": "    \"\"\"Find a bipartite graph with n vertices on each side, z edges, and no K_3,3 subgraph.\"\"\"",
    "sol_bodies": [
      "    from itertools import combinations\n    all_edges = [(a, b) for a in range(n) for b in range(n)]\n    for edges in combinations(all_edges, z):\n        edge_set = set(edges)\n        if all(any((a, b) not in edge_set for a in left for b in right)\n               for left in combinations(range(n), t)\n               for right in combinations(range(n), t)):\n            return [[a, b] for a, b in edges]"
    ],
    "module": "graphs.py",
    "notes": "[Zarankiewicz problem](https://en.wikipedia.org/wiki/Zarankiewicz_problem)",
    "weight": 1.0
  },
  {
    "name": "GraphIsomorphism:0",
    "sat": "def sat(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}",
    "ans_type": "List[int]",
    "sol_header": "def sol(g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):",
    "sol_docstring": "    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"",
    "sol_bodies": [
      "    # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""
    ],
    "module": "graphs.py",
    "notes": "The classic [Graph Isomorphism](https://en.wikipedia.org/wiki/Graph_isomorphism) problem.\nIt is unknown whether or not there exists a polynomial-time algorithm\nfor this problem, though an unpublished quasi-polynomial-time algorithm has been announced by Babai.\n\nThe classic version is a decision problem: given two graphs, determine whether or not they are isomorphic.\nHowever, it is polynomial-time equivalent to the one below through a standard reduction. In particular, if you\ncould solve the search problem below (finding the actual bijection), then you can decide isomorphism because the\nsearch solver would simply fail on non-isomorphic graphs. Conversely, if you could solve the decision problem,\nthen you can find a bijection as follows: if the decider determines that the graphs are isomorphic, for each node\nin the first graph, find a corresponding node in the second graph as follows. Add N self-edges from the node to\nitself where N is the maximum degree in the graph + 1, and do that for each candidate node in the second graph.\nFor each of these additions, test isomorphism. If the graphs are isomorphic then there must be a bijection that maps\nthe first node to the second. Repeat this for each node until you have found a bijection. (If self-loops are not\nallowed, one can do this by adding N additional nodes for each test.",
    "weight": 1.0
  },
  {
    "name": "ShortIntegerPath:0",
    "sat": "def sat(li: List[int]):\n    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128])) and len(li) == 9",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Find a list of nine integers, starting with 0 and ending with 128, such that each integer either differs from\n    the previous one by one or is thrice the previous one.\n    \"\"\"",
    "sol_bodies": [
      "    return [1, 3, 4, 12, 13, 14, 42, 126, 127]"
    ],
    "module": "graphs.py",
    "notes": "This is a more interesting version of Study_20 with an additional length constraint. One can think of the graph\ndefined by the integer pairs.",
    "weight": 1.0
  },
  {
    "name": "BiPermutations:0",
    "sat": "def sat(perms: List[List[int]], prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):\n    n = len(prices0)\n    perm0, perm1 = perms\n    assert sorted(perm0) == sorted(perm1) == list(range(n)), \"Solution must be two permutations\"\n    for i in range(n - 1):\n        assert prices0[perm0[i]] <= prices0[perm0[i + 1]], \"Permuted prices must be nondecreasing (row 0)\"\n        assert prices1[perm1[i]] <= prices1[perm1[i + 1]], \"Permuted prices must be nondecreasing (row 1)\"\n    return all(heights0[i] > heights1[j] for i, j in zip(perm0, perm1))",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(prices0=[7, 7, 9, 5, 3, 7, 1, 2], prices1=[5, 5, 5, 4, 2, 5, 1, 1], heights0=[2, 4, 9, 3, 8, 5, 5, 4], heights1=[1, 3, 8, 1, 5, 4, 4, 2]):",
    "sol_docstring": "    \"\"\"\n    There are two rows of objects. Given the length-n integer arrays of prices and heights of objects in each\n    row, find a permutation of both rows so that the permuted prices are non-decreasing in each row and\n    so that the first row is taller than the second row.\n    \"\"\"",
    "sol_bodies": [
      "    n = len(prices0)\n    prices = [prices0, prices1]\n    orders = [sorted(range(n), key=lambda i: (prices0[i], heights0[i])),\n              sorted(range(n), key=lambda i: (prices1[i], -heights1[i]))]\n    jumps = [1, 1]  # next price increase locations\n    for i in range(n):\n        for r, (p, o) in enumerate(zip(prices, orders)):\n            while jumps[r] < n and p[o[jumps[r]]] == p[o[i]]:\n                jumps[r] += 1\n\n        to_fix = orders[jumps[0] < jumps[1]]\n        j = i\n        while heights0[orders[0][i]] <= heights1[orders[1][i]]:\n            j += 1\n            to_fix[i], to_fix[j] = to_fix[j], to_fix[i]\n\n    return orders"
    ],
    "module": "ICPC.py",
    "notes": "Inspired by\n[ICPC 2019 Problem A: Azulejos](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 2,287 characters.",
    "weight": 1.0
  },
  {
    "name": "OptimalBridges:0",
    "sat": "def sat(indices: List[int], H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):\n    assert sorted({0, len(xs) - 1, *indices}) == indices, f\"Ans. should be sorted list [0, ..., {len(xs) - 1}]\"\n    cost = alpha * (H - ys[0])\n    for i, j in zip(indices, indices[1:]):\n        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2\n        assert max(ys[i], ys[j]) + r <= H, \"Bridge too tall\"\n        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \\\n            \"Bridge too short\"\n        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2\n    return cost <= thresh",
    "ans_type": "List[int]",
    "sol_header": "def sol(H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):",
    "sol_docstring": "    \"\"\"\n    You are to choose locations for bridge bases from among a given set of mountain peaks located at\n    `xs, ys`, where `xs` and `ys` are lists of n integers of the same length. Your answer should be a sorted\n    list of indices starting at 0 and ending at n-1. The goal is to minimize building costs such that the bridges\n    are feasible. The bridges are all semicircles placed on top of the pillars. The feasibility constraints are that:\n    * The bridges may not extend above a given height `H`. Mathematically, if the distance between the two xs\n    of adjacent pillars is d, then the semicircle will have radius `d/2` and therefore the heights of the\n    selected mountain peaks must both be at most `H - d/2`.\n    *  The bridges must clear all the mountain peaks, which means that the semicircle must lie above the tops of the\n    peak. See the code for how this is determined mathematically.\n    * The total cost of all the bridges must be at most `thresh`, where the cost is parameter alpha * (the sum of\n    all pillar heights) + beta * (the sum of the squared diameters)\n    \"\"\"",
    "sol_bodies": [
      "    # thresh is ignored\n    n = len(xs)\n    cost = [-1] * n\n    prior = [n] * n\n    cost[0] = beta * (H - ys[0])\n    for i in range(n):\n        if cost[i] == -1:\n            continue\n        min_d = 0\n        max_d = 2 * (H - ys[i])\n        for j in range(i + 1, n):\n            d = xs[j] - xs[i]\n            h = H - ys[j]\n            if d > max_d:\n                break\n            if 2 * h <= d:\n                min_d = max(min_d, 2 * d + 2 * h - int((8 * d * h) ** 0.5))\n            max_d = min(max_d, 2 * d + 2 * h + int((8 * d * h) ** 0.5))\n            if min_d > max_d:\n                break\n            if min_d <= d <= max_d:\n                new_cost = cost[i] + alpha * h + beta * d * d\n                if cost[j] == -1 or cost[j] > new_cost:\n                    cost[j] = new_cost\n                    prior[j] = i\n    rev_ans = [n - 1]\n    while rev_ans[-1] != 0:\n        rev_ans.append(prior[rev_ans[-1]])\n    return rev_ans[::-1]"
    ],
    "module": "ICPC.py",
    "notes": "Inspired by\n[ICPC 2019 Problem B: Bridges](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\nwhich is 3,003 characters.",
    "weight": 1.0
  },
  {
    "name": "CheckersPosition:0",
    "sat": "def sat(position: List[List[int]], transcript=[[[3, 3], [5, 5], [3, 7]], [[5, 3], [6, 4]]]):\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(transcript=[[[3, 3], [5, 5], [3, 7]], [[5, 3], [6, 4]]]):",
    "sol_docstring": "    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"",
    "sol_bodies": [
      "    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"
    ],
    "module": "ICPC.py",
    "notes": "Inspired by\n[ICPC 2019 Problem C: Checks Post Facto](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\n\nNobody solved this problem during the competition -- it is pretty difficult!",
    "weight": 1.0
  },
  {
    "name": "MatchingMarkers:0",
    "sat": "def sat(cut_position: int, ring=\"yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM\", lower=5):\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower",
    "ans_type": "int",
    "sol_header": "def sol(ring=\"yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM\", lower=5):",
    "sol_docstring": "    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"",
    "sol_bodies": [
      "    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"
    ],
    "module": "ICPC.py",
    "notes": "Inspired by\n[ICPC 2019 Problem D: Circular DNA](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\n\nThis is trivial in quadratic time, but the challenge is to solve it quickly (i.e., linear time).",
    "weight": 1.0
  },
  {
    "name": "ExponentialCoinMoves:0",
    "sat": "def sat(states: List[List[int]], n=16385):\n    assert states[0] == [1] * 5 and all(len(li) == 5 for li in states) and all(i >= 0 for li in states for i in li)\n    for prev, cur in zip(states, states[1:]):\n        for i in range(5):\n            if cur[i] != prev[i]:\n                break\n        assert cur[i] < prev[i]\n        assert (\n                cur[i + 1] - prev[i + 1] == 2 * (prev[i] - cur[i]) and cur[i + 2:] == prev[i + 2:]  # k decrements\n                or\n                cur[i:i + 3] == [prev[i] - 1, prev[i + 2], prev[i + 1]] and cur[i + 3:] == prev[i + 3:]  # swap\n        )\n\n    return states[-1][-1] == 2 ** n",
    "ans_type": "List[List[int]]",
    "sol_header": "def sol(n=16385):",
    "sol_docstring": "    \"\"\"\n    There are five boxes each having one coin initially. Two types of moves are allowed:\n    * (advance) remove `k > 0` coins from box `i` and add `2k` coins to box `i + 1`\n    * (swap) remove a coin from box `i` and swap the contents of boxes `i+1` and `i+2`\n    Given `0 <= n <= 16385`, find a sequence of states that result in 2^n coins in the last box.\n    Note that `n` can be as large as 16385 yielding 2^16385 coins (a number with 4,933 digits) in the last\n    box. Encode each state as a list of the numbers of coins in the five boxes.\n\n    Sample Input:\n    `n = 2`\n\n    Sample Output:\n    `[[1, 1, 1, 1, 1], [0, 3, 1, 1, 1], [0, 1, 5, 1, 1], [0, 1, 4, 1, 1], [0, 0, 1, 4, 1], [0, 0, 0, 1, 4]]`\n\n    The last box now has 2^2 coins. This is a sequence of two advances followed by three swaps.\n\n    states is encoded by lists of 5 coin counts\n    \"\"\"",
    "sol_bodies": [
      "    assert n >= 1\n    ans = [[1] * 5, [0, 3, 1, 1, 1], [0, 2, 3, 1, 1], [0, 2, 2, 3, 1], [0, 2, 2, 0, 7], [0, 2, 1, 7, 0],\n           [0, 2, 1, 0, 14], [0, 2, 0, 14, 0], [0, 1, 14, 0, 0]]\n\n    def exp_move():  # shifts last 3 [..., a, 0, 0] to [..., 0, 2^a, 0] for a>0\n        state = ans[-1][:]\n        state[2] -= 1\n        state[3] += 2\n        ans.append(state[:])\n        while state[2]:\n            state[3], state[4] = 0, 2 * state[3]\n            ans.append(state[:])\n            state[2:] = [state[2] - 1, state[4], 0]\n            ans.append(state[:])\n\n    exp_move()\n    assert ans[-1] == [0, 1, 0, 2 ** 14, 0]\n    ans.append([0, 0, 2 ** 14, 0, 0])\n    if n <= 16:\n        ans.append([0, 0, 0, 2 ** 15, 0])\n    else:\n        exp_move()\n        assert ans[-1] == [0, 0, 0, 2 ** (2 ** 14), 0]\n    state = ans[-1][:]\n    state[-2] -= 2 ** (n - 1)\n    state[-1] = 2 ** n\n    ans.append(state)\n    return ans"
    ],
    "module": "IMO.py",
    "notes": "This problem has *long* answers, not that the code to solve it is long but that what the solution outputs is long.\n\nThe version below uses only 5 boxes (unlike the IMO problem with 6 boxes since 2010^2010^2010 is too big\nfor computers) but the solution is quite similar to the solution to the IMO problem. Because the solution\nrequires exponential many moves, our representation allows combining multiple Type-1 (advance) operations\ninto a single step.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)",
    "weight": 10.0
  },
  {
    "name": "NoRelativePrimes:0",
    "sat": "def sat(nums: List[int], b=7, m=6):\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True",
    "ans_type": "List[int]",
    "sol_header": "def sol(b=7, m=6):",
    "sol_docstring": "    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"",
    "sol_bodies": [
      "    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans"
    ],
    "module": "IMO.py",
    "notes": "Inspired by [IMO 2016 Problem 4](https://www.imo-official.org/problems.aspx)\n\nQuestion: Is there a more efficient solution than the brute-force one we give, perhaps using the Chinese remainder\ntheorem?",
    "weight": 1.0
  },
  {
    "name": "FindRepeats:0",
    "sat": "def sat(indices: List[int], a0=123):\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1",
    "ans_type": "List[int]",
    "sol_header": "def sol(a0=123):",
    "sol_docstring": "    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"",
    "sol_bodies": [
      "    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"
    ],
    "module": "IMO.py",
    "notes": "Note: This problem is much easier than the IMO problem which also required a proof that it is impossible\nfor a_0 not divisible by 3.\n\nInspired by [IMO 2017 Problem 1](https://www.imo-official.org/problems.aspx)",
    "weight": 1.0
  },
  {
    "name": "PickNearNeighbors:0",
    "sat": "def sat(keep: List[bool], heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * n + n)), \"hint: heights is a permutation of range(n * n + n)\"\n    kept = [i for i, k in zip(heights, keep) if k]\n    assert len(kept) == 2 * n, \"must keep 2n items\"\n    pi = sorted(range(2 * n), key=lambda i: kept[i])  # the sort indices\n    return all(abs(pi[2 * i] - pi[2 * i + 1]) == 1 for i in range(n))",
    "ans_type": "List[bool]",
    "sol_header": "def sol(heights=[10, 2, 14, 1, 8, 19, 16, 6, 12, 3, 17, 0, 9, 18, 5, 7, 11, 13, 15, 4]):",
    "sol_docstring": "    \"\"\"\n    Given a permutation of the integers up to n(n+1) as a list, choose 2n numbers to keep (in the same order)\n    so that the remaining list of numbers satisfies:\n    * its largest number is next to its second largest number\n    * its third largest number is next to its fourth largest number\n    ...\n    * its second smallest number is next to its smallest number\n\n    Sample input:\n    [4, 0, 5, 3, 1, 2]\n    n = 2\n\n    Sample output:\n    [True, False, True, False, True, True]\n\n    Keeping these indices results in the sublist [4, 5, 1, 2] where 4 and 5 are adjacent as are 1 and 2.\n    \"\"\"",
    "sol_bodies": [
      "    # Based on the judge's solution.\n    n = int(len(heights) ** 0.5)\n    assert sorted(heights) == list(range(n * (n + 1)))\n    groups = [h // (n + 1) for h in heights]\n    ans = [False] * len(heights)\n    a = 0\n    used_groups = set()\n    while sum(ans) < 2 * n:\n        group_tracker = {}\n        b = a\n        while groups[b] not in group_tracker or groups[b] in used_groups:\n            group_tracker[groups[b]] = b\n            b += 1\n        ans[group_tracker[groups[b]]] = True\n        ans[b] = True\n        used_groups.add(groups[b])\n        a = b + 1\n    return ans"
    ],
    "module": "IMO.py",
    "notes": "Inspired by [IMO 2017 Problem 5](https://www.imo-official.org/problems.aspx)\n\nThe puzzle solution follows the judge's proof closely.",
    "weight": 1.0
  },
  {
    "name": "FindProductiveList:0",
    "sat": "def sat(li: List[int], n=18):\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=18):",
    "sol_docstring": "    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"",
    "sol_bodies": [
      "    return [-1, -1, 2] * (n // 3)"
    ],
    "module": "IMO.py",
    "notes": "Note: This problem is easier than the IMO problem because the hard part is proving that sequences do not\nexists for non-multiples of 3.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)",
    "weight": 1.0
  },
  {
    "name": "HalfTag:0",
    "sat": "def sat(li: List[int], tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):\n    n = max(tags) + 1\n    assert sorted(tags) == sorted(list(range(n)) * 4), \"hint: each tag occurs exactly four times\"\n    assert len(li) == len(set(li)) and min(li) >= 0\n    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]",
    "ans_type": "List[int]",
    "sol_header": "def sol(tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):",
    "sol_docstring": "    \"\"\"\n    The input tags is a list of 4n integer tags each in range(n) with each tag occurring 4 times.\n    The goal is to find a subset (list) li of half the indices such that:\n    * The sum of the indices equals the sum of the sum of the missing indices.\n    * The tags of the chosen indices contains exactly each number in range(n) twice.\n\n    Sample input:\n    n = 3\n    tags = [0, 1, 2, 0, 0, 1, 1, 1, 2, 2, 0, 2]\n\n    Sample output:\n    [0, 3, 5, 6, 8, 11]\n\n    Note the sum of the output is 33 = (0+1+2+...+11)/2 and the selected tags are [0, 0, 1, 1, 2, 2]\n    \"\"\"",
    "sol_bodies": [
      "    n = max(tags) + 1\n    pairs = {(i, 4 * n - i - 1) for i in range(2 * n)}\n    by_tag = {tag: [] for tag in range(n)}\n    for p in pairs:\n        a, b = [tags[i] for i in p]\n        by_tag[a].append(p)\n        by_tag[b].append(p)\n    cycles = []\n    cycle = []\n    while pairs:\n        if not cycle:  # start new cycle\n            p = pairs.pop()\n            pairs.add(p)  # just to pick a tag\n            tag = tags[p[0]]\n            # print(\"Starting cycle with tag\", tag)\n        p = by_tag[tag].pop()\n        a, b = [tags[i] for i in p]\n        # print(p, a, b)\n        tag = a if a != tag else b\n        by_tag[tag].remove(p)\n        cycle.append(p if tag == b else p[::-1])\n        pairs.remove(p)\n        if not by_tag[tag]:\n            cycles.append(cycle)\n            cycle = []\n\n    while any(len(c) % 2 for c in cycles):\n        cycle_tags = [{tags[k] for p in c for k in p} for c in cycles]\n        merged = False\n        for i in range(len(cycles)):\n            for j in range(i):\n                intersection = cycle_tags[i].intersection(cycle_tags[j])\n                if intersection:\n                    c = intersection.pop()\n                    # print(f\"Merging cycle {i} and cycle {j} at tag {c}\", cycles)\n                    cycle_i = cycles.pop(i)\n                    for i1, p in enumerate(cycle_i):\n                        if tags[p[0]] == c:\n                            break\n                    for j1, p in enumerate(cycles[j]):\n                        if tags[p[0]] == c:\n                            break\n                    cycles[j][j1:j1] = cycle_i[i1:] + cycle_i[:i1]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    ans = []\n    for c in cycles:\n        for i, p in enumerate(c):\n            if i % 2:\n                ans += p\n\n    return ans"
    ],
    "module": "IMO.py",
    "notes": "Inspired by [IMO 2020 Problem 3](https://www.imo-official.org/problems.aspx)",
    "weight": 1.0
  },
  {
    "name": "LearnParity:0",
    "sat": "def sat(inds: List[int], vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)",
    "ans_type": "List[int]",
    "sol_header": "def sol(vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):",
    "sol_docstring": "    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:\n    $\\\\sum_{i \\in S} x_i = 1 (mod 2)$\n    \"\"\"",
    "sol_bodies": [
      "    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"
    ],
    "module": "lattices.py",
    "notes": "Parity learning (Gaussian elimination)\n\nThe canonical solution to this \n[Parity learning problem](https://en.wikipedia.org/w/index.php?title=Parity_learning)\nis to use \n[Gaussian Elimination](https://en.wikipedia.org/w/index.php?title=Gaussian_elimination).\n\nThe vectors are encoded as binary integers for succinctness.",
    "weight": 1.0
  },
  {
    "name": "LearnParityWithNoise:0",
    "sat": "def sat(inds: List[int], vecs=[26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]):\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4",
    "ans_type": "List[int]",
    "sol_header": "def sol(vecs=[26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]):",
    "sol_docstring": "    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"",
    "sol_bodies": [
      "    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans"
    ],
    "module": "lattices.py",
    "notes": "Learn parity with noise (*unsolved*)\n\nThe fastest known algorithm to this\n[Parity learning problem](https://en.wikipedia.org/w/index.php?title=Parity_learning)\nruns in time $2^(d/(log d))$",
    "weight": 1.0
  },
  {
    "name": "FermatsLastTheorem:0",
    "sat": "def sat(nums: List[int]):\n    a, b, c, n = nums\n    return (a ** n + b ** n == c ** n) and min(a, b, c) > 0 and n > 2",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find integers a,b,c > 0, n > 2, such such that a^n + b^n == c^n\"\"\"",
    "sol_bodies": [],
    "module": "number_theory.py",
    "notes": "[Fermat's last theorem](https://en.wikipedia.org/w/index.php?title=Fermat%27s_Last_Theorem)\n\nSupposedly unsolvable, but how confident are really in the super-complicated proof?\n\nSee [Wiles, Andrew. \"Modular elliptic curves and Fermat's last theorem.\" Annals of mathematics 141.3 (1995): 443-551.](https://www.jstor.org/stable/2118559)",
    "weight": 1.0
  },
  {
    "name": "GCD:0",
    "sat": "def sat(n: int, a=15482, b=23223, lower_bound=5):\n    return a % n == 0 and b % n == 0 and n >= lower_bound",
    "ans_type": "int",
    "sol_header": "def sol(a=15482, b=23223, lower_bound=5):",
    "sol_docstring": "    \"\"\"Find a large common divisor of two integers.\"\"\"",
    "sol_bodies": [
      "    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n",
      "    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"
    ],
    "module": "number_theory.py",
    "notes": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
    "weight": 1.0
  },
  {
    "name": "GCD_multi:0",
    "sat": "def sat(n: int, nums=[77410, 23223, 54187], lower_bound=2):\n    return all(i % n == 0 for i in nums) and n >= lower_bound",
    "ans_type": "int",
    "sol_header": "def sol(nums=[77410, 23223, 54187], lower_bound=2):",
    "sol_docstring": "    \"\"\"Find a large common divisor of the list of integers.\"\"\"",
    "sol_bodies": [
      "    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"
    ],
    "module": "number_theory.py",
    "notes": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
    "weight": 1.0
  },
  {
    "name": "LCM:0",
    "sat": "def sat(n: int, a=15, b=27, upper_bound=150):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound",
    "ans_type": "int",
    "sol_header": "def sol(a=15, b=27, upper_bound=150):",
    "sol_docstring": "    \"\"\"Find a small common multiple of two integers.\"\"\"",
    "sol_bodies": [
      "    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"
    ],
    "module": "number_theory.py",
    "notes": "[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n(LCM)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
    "weight": 1.0
  },
  {
    "name": "LCM_multi:0",
    "sat": "def sat(n: int, nums=[15, 27, 102], upper_bound=5000):\n    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound",
    "ans_type": "int",
    "sol_header": "def sol(nums=[15, 27, 102], upper_bound=5000):",
    "sol_docstring": "    \"\"\"Find a small common multiple of a list of integers.\"\"\"",
    "sol_bodies": [
      "    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"
    ],
    "module": "number_theory.py",
    "notes": "[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n(LCM)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)",
    "weight": 1.0
  },
  {
    "name": "SmallExponentBigSolution:0",
    "sat": "def sat(n: int, b=2, target=5):\n    return (b ** n) % n == target",
    "ans_type": "int",
    "sol_header": "def sol(b=2, target=5):",
    "sol_docstring": "    \"\"\"Solve for n: b^n = target (mod n)\"\"\"",
    "sol_bodies": [
      "    for n in range(1, 10 ** 5):\n        if pow(b, n, n) == target:\n            return n"
    ],
    "module": "number_theory.py",
    "notes": "Small exponent, big solution\n\nProblems have small b and target but solution is typically a large n.\nSome of them are really hard, for example, for `b=2, target=3`, the smallest solution is `n=4700063497`\n\nSee [Richard K. Guy \"The strong law of small numbers\", (problem 13)](https://doi.org/10.2307/2322249)",
    "weight": 1.0
  },
  {
    "name": "ThreeCubes:0",
    "sat": "def sat(nums: List[int], target=983):\n    assert target % 9 not in [4, 5], \"Hint\"\n    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=983):",
    "sol_docstring": "    \"\"\"Given n, find integers a, b, c such that a^3 + b^3 + c^3 = n.\"\"\"",
    "sol_bodies": [
      "    assert target % 9 not in {4, 5}\n    for i in range(20):\n        for j in range(i + 1):\n            for k in range(-20, j + 1):\n                n = i ** 3 + j ** 3 + k ** 3\n                if n == target:\n                    return [i, j, k]\n                if n == -target:\n                    return [-i, -j, -k]"
    ],
    "module": "number_theory.py",
    "notes": "Sum of three cubes\n\nGiven `n`, find integers `a`, `b`, `c` such that `a**3 + b**3 + c**3 = n`. This is unsolvable for `n % 9 in {4, 5}`.\nConjectured to be true for all other n, i.e., `n % 9 not in {4, 5}`.\n`a`, `b`, `c` may be positive or negative\n\nSee [wikipedia entry](https://en.wikipedia.org/wiki/Sums_of_three_cubes) or\n[Andrew R. Booker, Andrew V. Sutherland (2020). \"On a question of Mordell.\"](https://arxiv.org/abs/2007.01209)",
    "weight": 1.0
  },
  {
    "name": "FourSquares:0",
    "sat": "def sat(nums: List[int], n=12345):\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=12345):",
    "sol_docstring": "    \"\"\"Find four integers whose squares sum to n\"\"\"",
    "sol_bodies": [
      "    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""
    ],
    "module": "number_theory.py",
    "notes": "Sum of four squares\n\n[Lagrange's Four Square Theorem](https://en.wikipedia.org/w/index.php?title=Lagrange%27s_four-square_theorem)\n\nGiven a non-negative integer `n`, a classic theorem of Lagrange says that `n` can be written as the sum of four\nintegers. The problem here is to find them. This is a nice problem and we give an elementary solution\nthat runs in time \tilde{O}(n),\nwhich is not \"polynomial time\" because it is not polynomial in log(n), the length of n. A poly-log(n)\nalgorithm using quaternions is described in the book:\n[\"Randomized algorithms in number theory\" by Michael O. Rabin and Jeffery O. Shallit (1986)](https://doi.org/10.1002/cpa.3160390713)\n\nThe first half of the problems involve small numbers and the second half involve some numbers up to 50 digits.",
    "weight": 1.0
  },
  {
    "name": "Factoring:0",
    "sat": "def sat(i: int, n=241864633):\n    return 1 < i < n and n % i == 0",
    "ans_type": "int",
    "sol_header": "def sol(n=241864633):",
    "sol_docstring": "    \"\"\"Find a non-trivial factor of integer n\"\"\"",
    "sol_bodies": [
      "    if n % 2 == 0:\n        return 2\n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n\n    assert False, \"problem defined for composite n only\""
    ],
    "module": "number_theory.py",
    "notes": "[Factoring](https://en.wikipedia.org/w/index.php?title=Integer_factorization) and\n[RSA challenge](https://en.wikipedia.org/w/index.php?title=RSA_numbers)\n\n*See class FermatComposite in codex.py for an easier composite test puzzle*\n\nThe factoring problems require one to find any nontrivial factor of n, which is equivalent to factoring by a\nsimple repetition process. Problems range from small (single-digit n) all the way to the \"RSA challenges\"\nwhich include several *unsolved* factoring problems put out by the RSA company. The challenge was closed in 2007,\nwith hundreds of thousands of dollars in unclaimed prize money for factoring their given numbers. People\ncontinue to work on them, nonetheless, and only the first 22/53 have RSA challenges have been solved thusfar.\n\nFrom Wikipedia:\n\nRSA-2048 has 617 decimal digits (2,048 bits). It is the largest of the RSA numbers and carried the largest\ncash prize for its factorization, $200,000. The RSA-2048 may not be factorizable for many years to come,\nunless considerable advances are made in integer factorization or computational power in the near future.",
    "weight": 1.0
  },
  {
    "name": "DiscreteLog:0",
    "sat": "def sat(n: int, g=44337, p=69337, t=38187):\n    return pow(g, n, p) == t",
    "ans_type": "int",
    "sol_header": "def sol(g=44337, p=69337, t=38187):",
    "sol_docstring": "    \"\"\"Find n such that g^n is congruent to t mod n\"\"\"",
    "sol_bodies": [
      "    for n in range(p):\n        if pow(g, n, p) == t:\n            return n\n    assert False, f\"unsolvable discrete log problem g={g}, t={t}, p={p}\""
    ],
    "module": "number_theory.py",
    "notes": "Discrete Log\n\nThe discrete logarithm problem is (given `g`, `t`, and `p`) to find n such that:\n\n`g ** n % p == t`\n\nFrom [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Discrete_logarithm_records):\n\n\"Several important algorithms in public-key cryptography base their security on the assumption\nthat the discrete logarithm problem over carefully chosen problems has no efficient solution.\"\n\nThe problem is *unsolved* in the sense that no known polynomial-time algorithm has been found.\n\nWe include McCurley's discrete log challenge from\n[Weber D., Denny T. (1998) \"The solution of McCurley's discrete log challenge.\"](https://link.springer.com/content/pdf/10.1007/BFb0055747.pdf)",
    "weight": 1.0
  },
  {
    "name": "GCD17:0",
    "sat": "def sat(n: int):\n    i = n ** 17 + 9\n    j = (n + 1) ** 17 + 9\n\n    while i != 0:  # compute gcd using Euclid's algorithm\n        (i, j) = (j % i, i)\n\n    return n >= 0 and j != 1",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find n for which gcd(n^17+9, (n+1)^17+9) != 1\"\"\"",
    "sol_bodies": [],
    "module": "number_theory.py",
    "notes": "According to [this article](https://primes.utm.edu/glossary/page.php?sort=LawOfSmall), the smallest\nsolution is 8424432925592889329288197322308900672459420460792433",
    "weight": 1.0
  },
  {
    "name": "Znam:0",
    "sat": "def sat(li: List[int], k=5):\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))",
    "ans_type": "List[int]",
    "sol_header": "def sol(k=5):",
    "sol_docstring": "    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"",
    "sol_bodies": [
      "    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"
    ],
    "module": "number_theory.py",
    "notes": "[Znam's Problem](https://en.wikipedia.org/wiki/Zn%C3%A1m%27s_problem)\n\nFor example [2, 3, 7, 47, 395] is a solution for k=5",
    "weight": 1.0
  },
  {
    "name": "CollatzCycleUnsolved:0",
    "sat": "def sat(n: int):\n    m = n\n    while n > 4:\n        n = 3 * n + 1 if n % 2 else n // 2\n        if n == m:\n            return True",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find n > 4 which is part of a cycle of this process\n    \"\"\"",
    "sol_bodies": [],
    "module": "number_theory.py",
    "notes": "Collatz Conjecture\n\nA solution to this problem would disprove the *Collatz Conjecture*, also called the *3n + 1 problem*,\nas well as the *Generalized Collatz Conjecture* (see the next problem).\nAccording to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture):\n> Paul Erdos said about the Collatz conjecture: \"Mathematics may not be ready for such problems.\"\n> He also offered US$500 for its solution. Jeffrey Lagarias stated in 2010 that the Collatz conjecture\n> \"is an extraordinarily difficult problem, completely out of reach of present day mathematics.\"\n\nConsider the following process. Start with an integer `n` and repeatedly applying the operation:\n* if n is even, divide n by 2,\n* if n is odd, multiply n by 3 and add 1\n\nThe conjecture is to that all `n > 0` eventually reach `n=1`. If this conjecture is false, then\nthere is either a cycle or a sequence that increases without bound. This problem seeks a cycle.",
    "weight": 1.0
  },
  {
    "name": "CollatzGeneralizedUnsolved:0",
    "sat": "def sat(start: int):\n    n = start  # could be positive or negative ...\n    while abs(n) > 1000:\n        n = 3 * n + 1 if n % 2 else n // 2\n        if n == start:\n            return True",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find n which is part of a cycle of this process that has |n| > 1000\n    \"\"\"",
    "sol_bodies": [],
    "module": "number_theory.py",
    "notes": "Generalized Collatz Conjecture\n\nThis version, permits negative n and seek a cycle with a number of magnitude greater than 1000,\nwhich would disprove the Generalized conjecture that states that the only cycles are the known 5 cycles\n(which don't have positive integers).\n\nSee the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)",
    "weight": 1.0
  },
  {
    "name": "CollatzDelay:0",
    "sat": "def sat(n: int, t=197, upper=20):\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper",
    "ans_type": "int",
    "sol_header": "def sol(t=197, upper=20):",
    "sol_docstring": "    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"",
    "sol_bodies": [
      "    # Faster solution for simultaneously solving multiple problems is of course possible\n    bound = t + 10\n    while True:\n        bound *= 2\n        prev = {1}\n        seen = set()\n        for delay in range(t):\n            seen.update(prev)\n            curr = {2 * n for n in prev}\n            curr.update({(n - 1) // 3 for n in prev if n % 6 == 4})\n            prev = {n for n in curr if n <= bound} - seen\n        if prev:\n            return min(prev)"
    ],
    "module": "number_theory.py",
    "notes": "Collatz Delay\n\nConsider the following process. Start with an integer `n` and repeatedly applying the operation:\n* if n is even, divide n by 2,\n* if n is odd, multiply n by 3 and add 1\nFind `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n\n\nFor instance,\nthe number `n=9780657630` takes 1,132 steps and the number `n=93,571,393,692,802,302` takes\n2,091 steps, according to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)\n\nNow, this problem can be solved trivially by taking exponentially large `n = 2 ** t` so we also bound the\nnumber of bits of the solution to be upper.\n\nSee [this webpage](http://www.ericr.nl/wondrous/delrecs.html) for up-to-date records.",
    "weight": 1.0
  },
  {
    "name": "Lehmer:0",
    "sat": "def sat(n: int):\n    return pow(2, n, n) == 3",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find n  such that 2^n mod n = 3\"\"\"",
    "sol_bodies": [
      "    return 4700063497"
    ],
    "module": "number_theory.py",
    "notes": "Lehmer puzzle\n\nAccording to [The Strong Law of Large Numbers](https://doi.org/10.2307/2322249) Richard K. Guy states that\n    D. H. & Emma Lehmer discovered that 2^n = 3 (mod n) for n = 4700063497,\n    but for no smaller n > 1",
    "weight": 1.0
  },
  {
    "name": "BirthdayParadox:0",
    "sat": "def sat(n: int, year_len=365):\n    prob = 1.0\n    for i in range(n):\n        prob *= (year_len - i) / year_len\n    return (prob - 0.5) ** 2 <= 1/year_len",
    "ans_type": "int",
    "sol_header": "def sol(year_len=365):",
    "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"",
    "sol_bodies": [
      "    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability.py",
    "notes": "Adaptation of the classic\n[Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem (Mathematical Problems category)).\n\nThe year length is year_len (365 is earth, while Neptune year is 60,182).",
    "weight": 1.0
  },
  {
    "name": "BirthdayParadoxMonteCarlo:0",
    "sat": "def sat(n: int, year_len=365):\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len",
    "ans_type": "int",
    "sol_header": "def sol(year_len=365):",
    "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"",
    "sol_bodies": [
      "    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"
    ],
    "module": "probability.py",
    "notes": "A slower, Monte Carlo version of the above Birthday Paradox problem.",
    "weight": 1.0
  },
  {
    "name": "BallotProblem:0",
    "sat": "def sat(counts: List[int], target_prob=0.5):\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6",
    "ans_type": "List[int]",
    "sol_header": "def sol(target_prob=0.5):",
    "sol_docstring": "    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"",
    "sol_bodies": [
      "    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"
    ],
    "module": "probability.py",
    "notes": "See the [Wikipedia article](https://en.wikipedia.org/wiki/Bertrand%27s_ballot_theorem) or\nor  [Addario-Berry L., Reed B.A. (2008) Ballot Theorems, Old and New. In: Gyori E., Katona G.O.H., Lov\u00e1sz L.,\nS\u00e1gi G. (eds) Horizons of Combinatorics. Bolyai Society Mathematical Studies, vol 17.\nSpringer, Berlin, Heidelberg.](https://doi.org/10.1007/978-3-540-77200-2_1)",
    "weight": 1.0
  },
  {
    "name": "BinomialProbabilities:0",
    "sat": "def sat(counts: List[int], p=0.5, target_prob=0.0625):\n    from itertools import product\n    a, b = counts\n    n = a + b\n    prob = (p ** a) * ((1-p) ** b)\n    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])\n    return abs(tot - target_prob) < 1e-6",
    "ans_type": "List[int]",
    "sol_header": "def sol(p=0.5, target_prob=0.0625):",
    "sol_docstring": "    \"\"\"Find counts = [a, b] so that the probability of  a H's and b T's among a + b coin flips is ~ target_prob.\"\"\"",
    "sol_bodies": [
      "    probs = [1.0]\n    q = 1 - p\n    while len(probs) < 20:\n        probs = [(p * a + q * b) for a, b in zip([0] + probs, probs + [0])]\n        answers = [i for i, p in enumerate(probs) if abs(p - target_prob) < 1e-6]\n        if answers:\n            return [answers[0], len(probs) - 1 - answers[0]]"
    ],
    "module": "probability.py",
    "notes": "See [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)",
    "weight": 1.0
  },
  {
    "name": "ExponentialProbability:0",
    "sat": "def sat(p_stop: float, steps=10, target_prob=0.5):\n    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))\n    return abs(prob - target_prob) < 1e-6",
    "ans_type": "float",
    "sol_header": "def sol(steps=10, target_prob=0.5):",
    "sol_docstring": "    \"\"\"\n    Find p_stop so that the probability of stopping in steps or fewer time steps is the given target_prob if you\n    stop each step with probability p_stop\n    \"\"\"",
    "sol_bodies": [
      "    return 1 - (1 - target_prob) ** (1.0/steps)"
    ],
    "module": "probability.py",
    "notes": "See [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution)",
    "weight": 1.0
  },
  {
    "name": "HelloWorld:0",
    "sat": "def sat(s: str):\n    return s + 'world' == 'Hello world'",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string that when concatenated onto 'world' gives 'Hello world'.\"\"\"",
    "sol_bodies": [],
    "module": "trivial_inverse.py",
    "notes": "Trivial example, no solutions provided",
    "weight": 0.2
  },
  {
    "name": "BackWorlds:0",
    "sat": "def sat(s: str):\n    return s[::-1] + 'world' == 'Hello world'",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string that when reversed and concatenated onto 'world' gives 'Hello world'.\"\"\"",
    "sol_bodies": [
      "    return ' olleH'",
      "    # solution methods must begin with 'sol'\n    return 'Hello '[::-1]"
    ],
    "module": "trivial_inverse.py",
    "notes": "We provide two solutions",
    "weight": 0.2
  },
  {
    "name": "StrAdd:0",
    "sat": "def sat(st: str, a=\"world\", b=\"Hello world\"):\n    return st + a == b",
    "ans_type": "str",
    "sol_header": "def sol(a=\"world\", b=\"Hello world\"):",
    "sol_docstring": "    \"\"\"Solve simple string addition problem.\"\"\"",
    "sol_bodies": [
      "    return b[:len(b) - len(a)]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrSetLen:0",
    "sat": "def sat(s: str, dups=2021):\n    return len(set(s)) == len(s) - dups",
    "ans_type": "str",
    "sol_header": "def sol(dups=2021):",
    "sol_docstring": "    \"\"\"Find a string with dups duplicate chars\"\"\"",
    "sol_bodies": [
      "    return \"a\" * (dups + 1)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrMul:0",
    "sat": "def sat(s: str, target=\"foofoofoofoo\", n=2):\n    return s * n == target",
    "ans_type": "str",
    "sol_header": "def sol(target=\"foofoofoofoo\", n=2):",
    "sol_docstring": "    \"\"\"Find a string which when repeated n times gives target\"\"\"",
    "sol_bodies": [
      "    if n == 0:\n        return ''\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrMul2:0",
    "sat": "def sat(n: int, target=\"foofoofoofoo\", s=\"foofoo\"):\n    return s * n == target",
    "ans_type": "int",
    "sol_header": "def sol(target=\"foofoofoofoo\", s=\"foofoo\"):",
    "sol_docstring": "    \"\"\"Find n such that s repeated n times gives target\"\"\"",
    "sol_bodies": [
      "    if len(s) == 0:\n        return 1\n    return len(target) // len(s)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrLen:0",
    "sat": "def sat(s: str, n=1000):\n    return len(s) == n",
    "ans_type": "str",
    "sol_header": "def sol(n=1000):",
    "sol_docstring": "    \"\"\"Find a string of length n\"\"\"",
    "sol_bodies": [
      "    return 'a' * n"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrAt:0",
    "sat": "def sat(i: int, s=\"cat\", target=\"a\"):\n    return s[i] == target",
    "ans_type": "int",
    "sol_header": "def sol(s=\"cat\", target=\"a\"):",
    "sol_docstring": "    \"\"\"Find the index of target in string s\"\"\"",
    "sol_bodies": [
      "    return s.index(target)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrNegAt:0",
    "sat": "def sat(i: int, s=\"cat\", target=\"a\"):\n    return s[i] == target and i < 0",
    "ans_type": "int",
    "sol_header": "def sol(s=\"cat\", target=\"a\"):",
    "sol_docstring": "    \"\"\"Find the index of target in s using a negative index.\"\"\"",
    "sol_bodies": [
      "    return - (len(s) - s.index(target))"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrSlice:0",
    "sat": "def sat(inds: List[int], s=\"hello world\", target=\"do\"):\n    i, j, k = inds\n    return s[i:j:k] == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(s=\"hello world\", target=\"do\"):",
    "sol_docstring": "    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"",
    "sol_bodies": [
      "    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrIndex:0",
    "sat": "def sat(s: str, big_str=\"foobar\", index=2):\n    return big_str.index(s) == index",
    "ans_type": "str",
    "sol_header": "def sol(big_str=\"foobar\", index=2):",
    "sol_docstring": "    \"\"\"Find a string whose *first* index in big_str is index\"\"\"",
    "sol_bodies": [
      "    return big_str[index:]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrIndex2:0",
    "sat": "def sat(big_str: str, sub_str=\"foobar\", index=2):\n    return big_str.index(sub_str) == index",
    "ans_type": "str",
    "sol_header": "def sol(sub_str=\"foobar\", index=2):",
    "sol_docstring": "    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"",
    "sol_bodies": [
      "    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrIn:0",
    "sat": "def sat(s: str, a=\"hello\", b=\"yellow\", length=4):\n    return len(s) == length and s in a and s in b",
    "ans_type": "str",
    "sol_header": "def sol(a=\"hello\", b=\"yellow\", length=4):",
    "sol_docstring": "    \"\"\"Find a string of length length that is in both strings a and b\"\"\"",
    "sol_bodies": [
      "    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrIn2:0",
    "sat": "def sat(substrings: List[str], s=\"hello\", count=15):\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)",
    "ans_type": "List[str]",
    "sol_header": "def sol(s=\"hello\", count=15):",
    "sol_docstring": "    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"",
    "sol_bodies": [
      "    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrCount:0",
    "sat": "def sat(string: str, substring=\"a\", count=10, length=100):\n    return string.count(substring) == count and len(string) == length",
    "ans_type": "str",
    "sol_header": "def sol(substring=\"a\", count=10, length=100):",
    "sol_docstring": "    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"",
    "sol_bodies": [
      "    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrSplit:0",
    "sat": "def sat(x: str, parts=['I', 'love', 'dumplings', '!'], length=100):\n    return len(x) == length and x.split() == parts",
    "ans_type": "str",
    "sol_header": "def sol(parts=['I', 'love', 'dumplings', '!'], length=100):",
    "sol_docstring": "    \"\"\"Find a string of a given length with a certain split\"\"\"",
    "sol_bodies": [
      "    joined = \" \".join(parts)\n    return joined + \" \" * (length - len(joined))"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrSplitter:0",
    "sat": "def sat(x: str, parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):\n    return string.split(x) == parts",
    "ans_type": "str",
    "sol_header": "def sol(parts=['I', 'love', 'dumplings', '!', ''], string=\"I_love_dumplings_!_\"):",
    "sol_docstring": "    \"\"\"Find a separator that when used to split a given string gives a certain result\"\"\"",
    "sol_bodies": [
      "    if len(parts) <= 1:\n        return string * 2\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrJoiner:0",
    "sat": "def sat(x: str, parts=['I!!', '!love', 'dumplings', '!', ''], string=\"I!!!!!love!!dumplings!!!!!\"):\n    return x.join(parts) == string",
    "ans_type": "str",
    "sol_header": "def sol(parts=['I!!', '!love', 'dumplings', '!', ''], string=\"I!!!!!love!!dumplings!!!!!\"):",
    "sol_docstring": "    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"",
    "sol_bodies": [
      "    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "StrParts:0",
    "sat": "def sat(parts: List[str], sep=\"!!\", string=\"I!!!!!love!!dumplings!!!!!\"):\n    return sep.join(parts) == string and all(sep not in p for p in parts)",
    "ans_type": "List[str]",
    "sol_header": "def sol(sep=\"!!\", string=\"I!!!!!love!!dumplings!!!!!\"):",
    "sol_docstring": "    \"\"\"Find parts that when joined give a specific string.\"\"\"",
    "sol_bodies": [
      "    return string.split(sep)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListSetLen:0",
    "sat": "def sat(li: List[int], dups=42155):\n    return len(set(li)) == len(li) - dups",
    "ans_type": "List[int]",
    "sol_header": "def sol(dups=42155):",
    "sol_docstring": "    \"\"\"Find a list with a certain number of duplicate items\"\"\"",
    "sol_bodies": [
      "    return [1] * (dups + 1)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListMul:0",
    "sat": "def sat(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):\n    return li * n == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(target=[17, 9, -1, 17, 9, -1], n=2):",
    "sol_docstring": "    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"",
    "sol_bodies": [
      "    if n == 0:\n        return []\n    return target[:len(target) // n]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListLen:0",
    "sat": "def sat(li: List[int], n=85012):\n    return len(li) == n",
    "ans_type": "List[int]",
    "sol_header": "def sol(n=85012):",
    "sol_docstring": "    \"\"\"Find a list of a given length n\"\"\"",
    "sol_bodies": [
      "    return [1] * n"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListAt:0",
    "sat": "def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    return li[i] == target",
    "ans_type": "int",
    "sol_header": "def sol(li=[17, 31, 91, 18, 42, 1, 9], target=18):",
    "sol_docstring": "    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"",
    "sol_bodies": [
      "    return li.index(target)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListNegAt:0",
    "sat": "def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):\n    return li[i] == target and i < 0",
    "ans_type": "int",
    "sol_header": "def sol(li=[17, 31, 91, 18, 42, 1, 9], target=91):",
    "sol_docstring": "    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"",
    "sol_bodies": [
      "    return li.index(target) - len(li)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListSlice:0",
    "sat": "def sat(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):\n    i, j, k = inds\n    return li[i:j:k] == target",
    "ans_type": "List[int]",
    "sol_header": "def sol(li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):",
    "sol_docstring": "    \"\"\"Find three slice indices to achieve a given list slice\"\"\"",
    "sol_bodies": [
      "    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListIndex:0",
    "sat": "def sat(item: int, li=[17, 2, 3, 9, 11, 11], index=4):\n    return li.index(item) == index",
    "ans_type": "int",
    "sol_header": "def sol(li=[17, 2, 3, 9, 11, 11], index=4):",
    "sol_docstring": "    \"\"\"Find the item whose first index in li is index\"\"\"",
    "sol_bodies": [
      "    return li[index]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListIndex2:0",
    "sat": "def sat(li: List[int], i=29, index=10412):\n    return li.index(i) == index",
    "ans_type": "List[int]",
    "sol_header": "def sol(i=29, index=10412):",
    "sol_docstring": "    \"\"\"Find a list that contains i first at index index\"\"\"",
    "sol_bodies": [
      "    return [i - 1] * index + [i]"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "ListIn:0",
    "sat": "def sat(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):\n    return s in a and s in b",
    "ans_type": "str",
    "sol_header": "def sol(a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):",
    "sol_docstring": "    \"\"\"Find an item that is in both lists a and b\"\"\"",
    "sol_bodies": [
      "    return next(s for s in b if s in a)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntNeg:0",
    "sat": "def sat(x: int, a=93252338):\n    return -x == a",
    "ans_type": "int",
    "sol_header": "def sol(a=93252338):",
    "sol_docstring": "    \"\"\"Solve a unary negation problem\"\"\"",
    "sol_bodies": [
      "    return - a"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntSum:0",
    "sat": "def sat(x: int, a=1073258, b=72352549):\n    return a + x == b",
    "ans_type": "int",
    "sol_header": "def sol(a=1073258, b=72352549):",
    "sol_docstring": "    \"\"\"Solve a sum problem\"\"\"",
    "sol_bodies": [
      "    return b - a"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntSub:0",
    "sat": "def sat(x: int, a=-382, b=14546310):\n    return x - a == b",
    "ans_type": "int",
    "sol_header": "def sol(a=-382, b=14546310):",
    "sol_docstring": "    \"\"\"Solve a subtraction problem\"\"\"",
    "sol_bodies": [
      "    return a + b"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntSub2:0",
    "sat": "def sat(x: int, a=8665464, b=-93206):\n    return a - x == b",
    "ans_type": "int",
    "sol_header": "def sol(a=8665464, b=-93206):",
    "sol_docstring": "    \"\"\"Solve a subtraction problem\"\"\"",
    "sol_bodies": [
      "    return a - b"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntMul:0",
    "sat": "def sat(n: int, a=14302, b=5):\n    return b * n + (a % b) == a",
    "ans_type": "int",
    "sol_header": "def sol(a=14302, b=5):",
    "sol_docstring": "    \"\"\"Solve a multiplication problem\"\"\"",
    "sol_bodies": [
      "    return a // b"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntDiv:0",
    "sat": "def sat(n: int, a=3, b=23463462):\n    return b // n == a",
    "ans_type": "int",
    "sol_header": "def sol(a=3, b=23463462):",
    "sol_docstring": "    \"\"\"Solve a division problem\"\"\"",
    "sol_bodies": [
      "    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntDiv2:0",
    "sat": "def sat(n: int, a=345346363, b=10):\n    return n // b == a",
    "ans_type": "int",
    "sol_header": "def sol(a=345346363, b=10):",
    "sol_docstring": "    \"\"\"Find n that when divided by b is a\"\"\"",
    "sol_bodies": [
      "    return a * b"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntSquareRoot:0",
    "sat": "def sat(x: int, a=10201202001):\n    return x ** 2 == a",
    "ans_type": "int",
    "sol_header": "def sol(a=10201202001):",
    "sol_docstring": "    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"",
    "sol_bodies": [
      "    return int(a ** 0.5)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "IntNegSquareRoot:0",
    "sat": "def sat(n: int, a=10000200001):\n    return a == n * n and n < 0",
    "ans_type": "int",
    "sol_header": "def sol(a=10000200001):",
    "sol_docstring": "    \"\"\"Find a negative integer that when squared equals perfect-square a.\"\"\"",
    "sol_bodies": [
      "    return -int(a ** 0.5)"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "FloatSquareRoot:0",
    "sat": "def sat(x: float, a=1020):\n    return abs(x ** 2 - a) < 10 ** -3",
    "ans_type": "float",
    "sol_header": "def sol(a=1020):",
    "sol_docstring": "    \"\"\"Find a number that when squared is close to a.\"\"\"",
    "sol_bodies": [
      "    return a ** 0.5"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "FloatNegSquareRoot:0",
    "sat": "def sat(x: float, a=1020):\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0",
    "ans_type": "float",
    "sol_header": "def sol(a=1020):",
    "sol_docstring": "    \"\"\"Find a negative number that when squared is close to a.\"\"\"",
    "sol_bodies": [
      "    return -a ** 0.5"
    ],
    "module": "trivial_inverse.py",
    "notes": "",
    "weight": 0.2
  },
  {
    "name": "Tutorial1:0",
    "sat": "def sat(s: str):\n    return \"Hello \" + s == \"Hello world\"",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"",
    "sol_bodies": [
      "    return \"world\""
    ],
    "module": "tutorial.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Tutorial2:0",
    "sat": "def sat(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"",
    "ans_type": "str",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"",
    "sol_bodies": [
      "    return \"world\"[::-1]"
    ],
    "module": "tutorial.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Tutorial3:0",
    "sat": "def sat(x: List[int]):\n    return len(x) == 2 and sum(x) == 3",
    "ans_type": "List[int]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of two integers whose sum is 3.\"\"\"",
    "sol_bodies": [
      "    return [1, 2]"
    ],
    "module": "tutorial.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Tutorial4:0",
    "sat": "def sat(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)",
    "ans_type": "List[str]",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"",
    "sol_bodies": [
      "    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]"
    ],
    "module": "tutorial.py",
    "notes": "",
    "weight": 1.0
  },
  {
    "name": "Tutorial5:0",
    "sat": "def sat(n: int):\n    return str(n * n).startswith(\"123456789\")",
    "ans_type": "int",
    "sol_header": "def sol():",
    "sol_docstring": "    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"",
    "sol_bodies": [
      "    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1"
    ],
    "module": "tutorial.py",
    "notes": "",
    "weight": 1.0
  }
]